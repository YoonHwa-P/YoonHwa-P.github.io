{"pages":[],"posts":[{"title":"Test page","text":"Hello world https://velog.io/@kwonhl0211/Hello-Kaggle-%EC%BA%90%EA%B8%80%EC%9D%B4-%EC%B2%98%EC%9D%8C%EC%9D%B8-%EB%B6%84%EB%93%A4%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%BA%90%EA%B8%80-%EA%B0%80%EC%9D%B4%EB%93%9C kaggle guide ko!! https://medium.com/@kaggleteam/how-to-get-started-with-data-science-in-containers-6ed48cb08266 Kaggle note랑 연동 하는 방법이 나와 있는듯나중에 Posting 해 봐야지 ^^ https://www.chartjs.org/docs/latest/samples/bar/horizontal.html chart에대해 많은 List가 있는데 완전 유용할듯 neo4j 를 이용하여 graph 만들수 있다.neo4j git blog: Hexo로 multi, push1234567git config --global user.email &quot;ssiasoda@gmil.com&quot;git config --global user.name &quot;YoonHwa-P&quot;git push origin HEAD:main 내가 push 할때 쓰려고 저장 Kaggle/competitionskaggle competition에 참가 할 수 있다. 1!pip install kaggle Requirement already satisfied: kaggle in /usr/local/lib/python3.7/dist-packages (1.5.12) Requirement already satisfied: python-dateutil in /usr/local/lib/python3.7/dist-packages (from kaggle) (2.8.2) Requirement already satisfied: urllib3 in /usr/local/lib/python3.7/dist-packages (from kaggle) (1.24.3) Requirement already satisfied: six&gt;=1.10 in /usr/local/lib/python3.7/dist-packages (from kaggle) (1.15.0) Requirement already satisfied: requests in /usr/local/lib/python3.7/dist-packages (from kaggle) (2.23.0) Requirement already satisfied: python-slugify in /usr/local/lib/python3.7/dist-packages (from kaggle) (5.0.2) Requirement already satisfied: certifi in /usr/local/lib/python3.7/dist-packages (from kaggle) (2021.5.30) Requirement already satisfied: tqdm in /usr/local/lib/python3.7/dist-packages (from kaggle) (4.62.3) Requirement already satisfied: text-unidecode&gt;=1.3 in /usr/local/lib/python3.7/dist-packages (from python-slugify-&gt;kaggle) (1.3) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.7/dist-packages (from requests-&gt;kaggle) (3.0.4) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.7/dist-packages (from requests-&gt;kaggle) (2.10) 12345678910from google.colab import filesuploaded = files.upload()for fn in uploaded.keys(): print('User uploaded file &quot;{name}&quot; with length {length} bytes'.format( name=fn, length=len(uploaded[fn]))) # Then move kaggle.json into the folder where the API expects to find it.!mkdir -p ~/.kaggle/ &amp;&amp; mv kaggle.json ~/.kaggle/ &amp;&amp; chmod 600 ~/.kaggle/kaggle.json Upload widget is only available when the cell has been executed in the current browser session. Please rerun this cell to enable. --------------------------------------------------------------------------- KeyboardInterrupt Traceback (most recent call last) &lt;ipython-input-57-5e2b5f92ba05&gt; in &lt;module&gt;() 1 from google.colab import files 2 ----&gt; 3 uploaded = files.upload() 4 5 for fn in uploaded.keys(): /usr/local/lib/python3.7/dist-packages/google/colab/files.py in upload() 62 result = _output.eval_js( 63 'google.colab._files._uploadFiles(&quot;{input_id}&quot;, &quot;{output_id}&quot;)'.format( ---&gt; 64 input_id=input_id, output_id=output_id)) 65 files = _collections.defaultdict(_six.binary_type) 66 # Mapping from original filename to filename as saved locally. /usr/local/lib/python3.7/dist-packages/google/colab/output/_js.py in eval_js(script, ignore_result, timeout_sec) 38 if ignore_result: 39 return ---&gt; 40 return _message.read_reply_from_input(request_id, timeout_sec) 41 42 /usr/local/lib/python3.7/dist-packages/google/colab/_message.py in read_reply_from_input(message_id, timeout_sec) 99 reply = _read_next_input_message() 100 if reply == _NOT_READY or not isinstance(reply, dict): --&gt; 101 time.sleep(0.025) 102 continue 103 if (reply.get('type') == 'colab_reply' and KeyboardInterrupt: 데이터 다운로드 및 불러오기1!kaggle competitions list Warning: Looks like you're using an outdated API Version, please consider updating (server 1.5.12 / client 1.5.4) ref deadline category reward teamCount userHasEntered --------------------------------------------- ------------------- --------------- --------- --------- -------------- contradictory-my-dear-watson 2030-07-01 23:59:00 Getting Started Prizes 63 False gan-getting-started 2030-07-01 23:59:00 Getting Started Prizes 81 False store-sales-time-series-forecasting 2030-06-30 23:59:00 Getting Started Knowledge 487 False tpu-getting-started 2030-06-03 23:59:00 Getting Started Knowledge 157 False digit-recognizer 2030-01-01 00:00:00 Getting Started Knowledge 1459 False titanic 2030-01-01 00:00:00 Getting Started Knowledge 14879 False house-prices-advanced-regression-techniques 2030-01-01 00:00:00 Getting Started Knowledge 4418 True connectx 2030-01-01 00:00:00 Getting Started Knowledge 263 False nlp-getting-started 2030-01-01 00:00:00 Getting Started Knowledge 1321 False competitive-data-science-predict-future-sales 2022-12-31 23:59:00 Playground Kudos 12891 False g-research-crypto-forecasting 2022-02-01 23:59:00 Featured $125,000 148 False petfinder-pawpularity-score 2022-01-13 23:59:00 Research $25,000 1631 False optiver-realized-volatility-prediction 2022-01-10 23:59:00 Featured $100,000 3852 False nfl-big-data-bowl-2022 2022-01-06 23:59:00 Analytics $100,000 0 False sartorius-cell-instance-segmentation 2021-12-30 23:59:00 Featured $75,000 495 False wikipedia-image-caption 2021-12-09 11:59:00 Playground Swag 71 False lux-ai-2021 2021-12-06 23:59:00 Featured $10,000 928 False tabular-playground-series-nov-2021 2021-11-30 23:59:00 Playground Swag 352 False kaggle-survey-2021 2021-11-28 23:59:00 Analytics $30,000 0 False chaii-hindi-and-tamil-question-answering 2021-11-15 23:59:00 Research $10,000 807 False 1!kaggle competitions download -c house-prices-advanced-regression-techniques User cancelled operation 1234import pandas as pd train = pd.read_csv('train.csv')test = pd.read_csv('test.csv')print('Data Loading is done!') Data Loading is done! 데이터 둘러보기12print(&quot;The shape of Train Data is:&quot;, train.shape)print(&quot;The shape of Test Data is:&quot;, test.shape) The shape of Train Data is: (1460, 81) The shape of Test Data is: (1459, 80) 1print(train.info()) &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 1460 entries, 0 to 1459 Data columns (total 81 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Id 1460 non-null int64 1 MSSubClass 1460 non-null int64 2 MSZoning 1460 non-null object 3 LotFrontage 1201 non-null float64 4 LotArea 1460 non-null int64 5 Street 1460 non-null object 6 Alley 91 non-null object 7 LotShape 1460 non-null object 8 LandContour 1460 non-null object 9 Utilities 1460 non-null object 10 LotConfig 1460 non-null object 11 LandSlope 1460 non-null object 12 Neighborhood 1460 non-null object 13 Condition1 1460 non-null object 14 Condition2 1460 non-null object 15 BldgType 1460 non-null object 16 HouseStyle 1460 non-null object 17 OverallQual 1460 non-null int64 18 OverallCond 1460 non-null int64 19 YearBuilt 1460 non-null int64 20 YearRemodAdd 1460 non-null int64 21 RoofStyle 1460 non-null object 22 RoofMatl 1460 non-null object 23 Exterior1st 1460 non-null object 24 Exterior2nd 1460 non-null object 25 MasVnrType 1452 non-null object 26 MasVnrArea 1452 non-null float64 27 ExterQual 1460 non-null object 28 ExterCond 1460 non-null object 29 Foundation 1460 non-null object 30 BsmtQual 1423 non-null object 31 BsmtCond 1423 non-null object 32 BsmtExposure 1422 non-null object 33 BsmtFinType1 1423 non-null object 34 BsmtFinSF1 1460 non-null int64 35 BsmtFinType2 1422 non-null object 36 BsmtFinSF2 1460 non-null int64 37 BsmtUnfSF 1460 non-null int64 38 TotalBsmtSF 1460 non-null int64 39 Heating 1460 non-null object 40 HeatingQC 1460 non-null object 41 CentralAir 1460 non-null object 42 Electrical 1459 non-null object 43 1stFlrSF 1460 non-null int64 44 2ndFlrSF 1460 non-null int64 45 LowQualFinSF 1460 non-null int64 46 GrLivArea 1460 non-null int64 47 BsmtFullBath 1460 non-null int64 48 BsmtHalfBath 1460 non-null int64 49 FullBath 1460 non-null int64 50 HalfBath 1460 non-null int64 51 BedroomAbvGr 1460 non-null int64 52 KitchenAbvGr 1460 non-null int64 53 KitchenQual 1460 non-null object 54 TotRmsAbvGrd 1460 non-null int64 55 Functional 1460 non-null object 56 Fireplaces 1460 non-null int64 57 FireplaceQu 770 non-null object 58 GarageType 1379 non-null object 59 GarageYrBlt 1379 non-null float64 60 GarageFinish 1379 non-null object 61 GarageCars 1460 non-null int64 62 GarageArea 1460 non-null int64 63 GarageQual 1379 non-null object 64 GarageCond 1379 non-null object 65 PavedDrive 1460 non-null object 66 WoodDeckSF 1460 non-null int64 67 OpenPorchSF 1460 non-null int64 68 EnclosedPorch 1460 non-null int64 69 3SsnPorch 1460 non-null int64 70 ScreenPorch 1460 non-null int64 71 PoolArea 1460 non-null int64 72 PoolQC 7 non-null object 73 Fence 281 non-null object 74 MiscFeature 54 non-null object 75 MiscVal 1460 non-null int64 76 MoSold 1460 non-null int64 77 YrSold 1460 non-null int64 78 SaleType 1460 non-null object 79 SaleCondition 1460 non-null object 80 SalePrice 1460 non-null int64 dtypes: float64(3), int64(35), object(43) memory usage: 924.0+ KB None 1print(test.info()) &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 1459 entries, 0 to 1458 Data columns (total 80 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Id 1459 non-null int64 1 MSSubClass 1459 non-null int64 2 MSZoning 1455 non-null object 3 LotFrontage 1232 non-null float64 4 LotArea 1459 non-null int64 5 Street 1459 non-null object 6 Alley 107 non-null object 7 LotShape 1459 non-null object 8 LandContour 1459 non-null object 9 Utilities 1457 non-null object 10 LotConfig 1459 non-null object 11 LandSlope 1459 non-null object 12 Neighborhood 1459 non-null object 13 Condition1 1459 non-null object 14 Condition2 1459 non-null object 15 BldgType 1459 non-null object 16 HouseStyle 1459 non-null object 17 OverallQual 1459 non-null int64 18 OverallCond 1459 non-null int64 19 YearBuilt 1459 non-null int64 20 YearRemodAdd 1459 non-null int64 21 RoofStyle 1459 non-null object 22 RoofMatl 1459 non-null object 23 Exterior1st 1458 non-null object 24 Exterior2nd 1458 non-null object 25 MasVnrType 1443 non-null object 26 MasVnrArea 1444 non-null float64 27 ExterQual 1459 non-null object 28 ExterCond 1459 non-null object 29 Foundation 1459 non-null object 30 BsmtQual 1415 non-null object 31 BsmtCond 1414 non-null object 32 BsmtExposure 1415 non-null object 33 BsmtFinType1 1417 non-null object 34 BsmtFinSF1 1458 non-null float64 35 BsmtFinType2 1417 non-null object 36 BsmtFinSF2 1458 non-null float64 37 BsmtUnfSF 1458 non-null float64 38 TotalBsmtSF 1458 non-null float64 39 Heating 1459 non-null object 40 HeatingQC 1459 non-null object 41 CentralAir 1459 non-null object 42 Electrical 1459 non-null object 43 1stFlrSF 1459 non-null int64 44 2ndFlrSF 1459 non-null int64 45 LowQualFinSF 1459 non-null int64 46 GrLivArea 1459 non-null int64 47 BsmtFullBath 1457 non-null float64 48 BsmtHalfBath 1457 non-null float64 49 FullBath 1459 non-null int64 50 HalfBath 1459 non-null int64 51 BedroomAbvGr 1459 non-null int64 52 KitchenAbvGr 1459 non-null int64 53 KitchenQual 1458 non-null object 54 TotRmsAbvGrd 1459 non-null int64 55 Functional 1457 non-null object 56 Fireplaces 1459 non-null int64 57 FireplaceQu 729 non-null object 58 GarageType 1383 non-null object 59 GarageYrBlt 1381 non-null float64 60 GarageFinish 1381 non-null object 61 GarageCars 1458 non-null float64 62 GarageArea 1458 non-null float64 63 GarageQual 1381 non-null object 64 GarageCond 1381 non-null object 65 PavedDrive 1459 non-null object 66 WoodDeckSF 1459 non-null int64 67 OpenPorchSF 1459 non-null int64 68 EnclosedPorch 1459 non-null int64 69 3SsnPorch 1459 non-null int64 70 ScreenPorch 1459 non-null int64 71 PoolArea 1459 non-null int64 72 PoolQC 3 non-null object 73 Fence 290 non-null object 74 MiscFeature 51 non-null object 75 MiscVal 1459 non-null int64 76 MoSold 1459 non-null int64 77 YrSold 1459 non-null int64 78 SaleType 1458 non-null object 79 SaleCondition 1459 non-null object dtypes: float64(11), int64(26), object(43) memory usage: 912.0+ KB None","link":"/2021/10/28/1028/"},{"title":"become a BDS","text":"##Big data 를 이용 할 수 있는 BioData Scientist가 되고 싶다. 생물학은 점점 디지털화되고 있으며 이제 양적인 과학 분야의 빛을 발하고 있다. 핵심 추진 요인은 생물학적 연구에서 처리량이 높은 기술 플랫폼의 확산이 증가하는 것으로,체계적인 연구를 위해 수천 개의 조직과 유기체에 걸친유전자, 단백질 및 기타 생물학적 부분에 대한 수백만 개의 데이터 포인트가수집, 세척, 저장 및 통합될 수 있도록 한다. 이처럼 데이터가 풍부한 환경에서 생물학적(그리고 임상 샘플에 배치된 경우 생물의학)연구의 미래는 데이터의 전략적 극대화 에 있다고 해도 과언이 아니다. 오늘날의 기술 환경에서 데이터 과학 및 인공지능(AI)은이미 비즈니스 및 금융과 같은 영역에서 혁신 동력으로 작용하고 있다.여기서 데이터 과학자는 막후에서 작업하는 대신 데이터를 실질적인통찰력으로 변환하는 역할을 담당하고 있다. 예를 들어, 인공지능 기반 알고리즘 거래와 금융 기술(FinTech)의 주식 추천 시스템,엔지니어링의 자동화 엔진 설계, 시스템 유지보수 및 로봇공학 등이 있다.최근의 데이터 폭발과 이에 따른 비즈니스, 금융 및 컴퓨팅과 같은다른 분야의 데이터 과학의 발전을 감안할 때, 우리는 특히 생물학과 관련된 영역별문제를 다루는 새로운 변형인 빠르고 방대한 양의 데이터 생성과 함께 데이터 과학이등장할 것으로 예상한다. 이를 “바이오 데이터 과학” 이라고 한다. ###BDS(BioData Science)에는 세 가지 핵심 분야가 있다. 생물학 영역: Biology 수학 및 통계 : mathematics (statistics) 컴퓨터 공학 : computer science 생물학 영역은 질병의 원인이나 유추된 바이오 마커의 진단 효용 이해와 같은 생물학적 기원에 대한 질문과 관련이 있다. 컴퓨터 과학 코어는 특히 분석할 데이터가 큰 경우 문제 해결을 위한 적절한알고리즘 고안, 반복 처리 (예: 데이터의 큰 부분 집합에서동일한 알고리즘 여러 번 실행) 및 데이터 저장 문제 해결과 관련이 있다. 수학 및 통계 핵심 영역은 데이터 요약, 정규화 및 모델링을 포함한 문제와 관련이 있다.기술 및 탐색적 통계 데이터 분석이 BDS에만 국한된 것은 아니지만(생물 통계의 필수 구성 요소이기도 하며, 더 낮은 정도로 생물 정보학이기도 함),BDS는 빅데이터에 AI/ML을 적용하는 것에 기초한 신흥 기술을 이용한 예측에 초점을 맞추고 있다. ###바이오 데이터 과학은 다른 과학 분야와 다르지 않은 탐구 과학이다.BDS는 단순히 기술(technology), 기계 학습(machine learning) 인공지능(AI)이 아니다. 인공지능이 여러분을 위해 그렇게 해주기를 바라는 대신, 사람의 강한 논리적 사고에 기초해야 한다.BDS가 궁극적으로 연구의 과학이라는 이런 점에서, 전형적인 과학적 조사와 다르지 않다. 우리는 유전자 발현 변화가 정신 상태와 의미있게 상관되는지에 대한 질문에 답하도록 돕기 위해다음의 7가지 단계를 사용할 수 있다. 가장 큰 차이점은 BDS는 낮은 처리량 또는 저전력 물리적 실험에 대한 강조를 줄이면서의미 있는 데이터 조작 및 분석에 강력한 능력을 필요로 한다는 것이다. 데이터 과학은 다른 과학적 추구와 같은 과정으로 진행 된다. - 조사할 질문을 먼저 선택 - 테스트 가능한 관련 가설을 확인함으로써 이 질문의 범위를 넓힘 - 가설에 답하기 위한 데이터를 얻기 위한 적절한 실험을 설계하고 현장 적용할 - 결과를 결정하고 그 타당성, 즉 데이터가 연구 질문에 답하는 데 적합한지 여부를 평가 - 마지막으로, 모델을 배치하고 연구 결과가 반복 가능한지 확인 ###데이터 분석은 복잡한 다단계 프로세스이다.**BDS(BioData Science)**는 도전적인 분야이지만, 생물정보학이나 전산생물학과 비슷하게 어렵다. 생물학적 시스템을 측정하기 위한 기술적 플랫폼은 매우 정교하지만, 생물학적 시스템은 매우 복잡하다.게다가 생물학적 실체를 측정하기 위해 개발된 기술적 도구는 생물학적 시스템의구성요소가 변화하고 시간이 지남에 따라 자연스럽게 변화하는 동안 기술적 불확실성에 영향을 받는다.바이오 빅 데이터는 이러한 문제에 대한 자연스러운 솔루션이 아니며 새로운 문제를 야기한다. BDS 데이터는 매우 많은 수의 관측에서 보존된 패턴을 식별하는 과정과 같은 데이터 과학노력을 촉진할 수 있지만, 적절한 분석 파이프라인이 개발될 경우에만 그렇게 할 수 있다.이 작업은 하찮지 않다. 이러한 분석 파이프라인은 데이터 수집에서 시작하여더 높은 수준의 생물학적 해석과 통찰력을 향한 계산 및 통계 평가를 통해 계속 이어지는다양한 접근 방식의 엔드 투 엔드 통합으로 상상할 수 있다. omics 데이터의 바이오 마커 분석을 위한 단순화된 파이프라인과 관련 주요 고려 사항은 다음과 같을 수 있다. 분석 파이프라인은 매우 유연해야 하며 연구 질문의 필요에 따라 변화해야 한다.완벽한 지식이 부족하기 때문에 최적화와 재현성을 어느 정도 달성하기 위해 몇 단계를 왔다 갔다반복하고 다듬는 것도 일반적이다. 예를 들어, 정규화 단계에서 두 개의 서로 다른 정규화 절차를사용하여 매우 다르고 겹치지 않는 차등 유전자 세트를 발견했다고 가정 해 보자.정규화 절차는 데이터에 대해 잘못된 가정을 하거나 잘못 구현되었을 수 있다.표시된 주요 고려사항은 엄청나게 많다. 고려사항의 예와 함께 단계를 보여주는 목적은각 단계마다 완벽한 시스템이나 파이프라인이 없지만, 각 의사결정 지점마다 이후 단계에 대한결과를 갖는 많은 고려사항이 있음을 입증하는 것이다. 우리는 또한 특정 정규화 접근법이 다운스트림 통계 절차와 잘 작동하는지와 같은호환성 문제나 특정 절차가 배치 효과 보정 알고리즘 및 일부 다중 시험 보정 방법과 관련된과다 탈락 및 과다 첨가로 이어질 수 있는지 여부와 같은 문제를 걱정해야 한다. 일반적으로 좋은 결과를 보장하는 노선도나 표준 운영 절차는 없다는 점에서BDS는 예술에 가까운 과학인 것이다. Ref.https://gohwils.github.io/biodatascience/biodatascience.html","link":"/2021/11/04/BDS/"},{"title":"Google Colaboratory file을 GitHube에 Upload하기","text":"Google Colaboratory file을 GitHub에 바로 올리기 ###google Colaboratory란? google Colaboratory (G-CLB, 구글 코랩)로 작업 했다면 이 file을 바로 gitHub blog에 올리고 싶을 것이다.우리는 다음과 같은 과정을 통해 G-CLB file을 다른 변환 과정 없이 file 째로 올릴 수 있다. 우리에게 필요한 app은 ‘아나콘다’ 이다. Anaconda의 JupyterLab을 이용하여 변환 해 봅시다. 아나콘다의 주피터랩&gt; file Tab에서 Export Note로 간다 MarkDown file으로 다운 받아서 _post 경로에 넣어주면 완성 !!! 다른 방법도 있다. !!","link":"/2021/11/01/GC_Upload_GH/"},{"title":"decisionTree Classifier()","text":"DecisionTreeClassifier##Classifier function Decision Tree Classifier는 데이터 집합에서 다중 클래스 분류를 수행할 수 있는 클래스이다. 다른 분류자와 마찬가지로 Decision Tre Classifier는 훈련 샘플을 고정하는 배열 X(n_샘플, n_특징)와 훈련 샘플에 대한 클래스 레이블을 고정하는 정수 값, 형상(n_샘플, n_특징)의 배열 Y의 두 배열을 입력으로 사용합니다. 12345from sklearn import treeX = [[0, 0], [1, 1]]Y = [0, 1]clf = tree.DecisionTreeClassifier()clf = clf.fit(X, Y) 이제 예측 모델을 만들어 봅시다. 12clf.predict([[2., 2.]])clf.predict_proba([[2., 2.]]) array([[0., 1.]]) 의사결정트리의 분류는 classification과 multiclass 양쪽으로 모두 분류 할 수 있다. iris dataset을 하용하면, 우리는 아래와 같은 plot_Tree를 만들 수 잇다. 1234567from sklearn.datasets import load_irisfrom sklearn import treeiris = load_iris()x, y = iris.data, iris.targetclf = tree.DecisionTreeClassifier()clf = clf.fit(x, y)tree.plot_tree(clf) [Text(167.4, 199.32, 'X[2] &lt;= 2.45\\ngini = 0.667\\nsamples = 150\\nvalue = [50, 50, 50]'), Text(141.64615384615385, 163.07999999999998, 'gini = 0.0\\nsamples = 50\\nvalue = [50, 0, 0]'), Text(193.15384615384616, 163.07999999999998, 'X[3] &lt;= 1.75\\ngini = 0.5\\nsamples = 100\\nvalue = [0, 50, 50]'), Text(103.01538461538462, 126.83999999999999, 'X[2] &lt;= 4.95\\ngini = 0.168\\nsamples = 54\\nvalue = [0, 49, 5]'), Text(51.50769230769231, 90.6, 'X[3] &lt;= 1.65\\ngini = 0.041\\nsamples = 48\\nvalue = [0, 47, 1]'), Text(25.753846153846155, 54.359999999999985, 'gini = 0.0\\nsamples = 47\\nvalue = [0, 47, 0]'), Text(77.26153846153846, 54.359999999999985, 'gini = 0.0\\nsamples = 1\\nvalue = [0, 0, 1]'), Text(154.52307692307693, 90.6, 'X[3] &lt;= 1.55\\ngini = 0.444\\nsamples = 6\\nvalue = [0, 2, 4]'), Text(128.76923076923077, 54.359999999999985, 'gini = 0.0\\nsamples = 3\\nvalue = [0, 0, 3]'), Text(180.27692307692308, 54.359999999999985, 'X[2] &lt;= 5.45\\ngini = 0.444\\nsamples = 3\\nvalue = [0, 2, 1]'), Text(154.52307692307693, 18.119999999999976, 'gini = 0.0\\nsamples = 2\\nvalue = [0, 2, 0]'), Text(206.03076923076924, 18.119999999999976, 'gini = 0.0\\nsamples = 1\\nvalue = [0, 0, 1]'), Text(283.2923076923077, 126.83999999999999, 'X[2] &lt;= 4.85\\ngini = 0.043\\nsamples = 46\\nvalue = [0, 1, 45]'), Text(257.53846153846155, 90.6, 'X[1] &lt;= 3.1\\ngini = 0.444\\nsamples = 3\\nvalue = [0, 1, 2]'), Text(231.7846153846154, 54.359999999999985, 'gini = 0.0\\nsamples = 2\\nvalue = [0, 0, 2]'), Text(283.2923076923077, 54.359999999999985, 'gini = 0.0\\nsamples = 1\\nvalue = [0, 1, 0]'), Text(309.04615384615386, 90.6, 'gini = 0.0\\nsamples = 43\\nvalue = [0, 0, 43]')] decision tree는 약 20여종의 parameter가 있다. Parameter criterion : 분할 품질을 측정하는 기능 (default : gini) splitter : 각 노드에서 분할을 선택하는 데 사용되는 전략 (default : best) max_depth : 트리의 최대 깊이 (값이 클수록 모델의 복잡도가 올라간다.) min_samples_split : 자식 노드를 분할하는데 필요한 최소 샘플 수 (default : 2) min_samples_leaf : 리프 노드에 있어야 할 최소 샘플 수 (default : 1) min_weight_fraction_leaf : min_sample_leaf와 같지만 가중치가 부여된 샘플 수에서의 비율 max_features : 각 노드에서 분할에 사용할 특징의 최대 수 random_state : 난수 seed 설정 max_leaf_nodes : 리프 노드의 최대수 min_impurity_decrease : 최소 불순도 min_impurity_split : 나무 성장을 멈추기 위한 임계치 class_weight : 클래스 가중치 presort : 데이터 정렬 필요 여부 12sklearn.tree.plot_tree(decision_tree, *, max_depth=None, feature_names=None, class_names=None, label='all', filled=False, impurity=True, node_ids=False, proportion=False, rounded=False, precision=3, ax=None, fontsize=None)tree.plot_tree() 가장 원시적이면서 기본적인 parameter가 있는 decision tree의 parameter를 외우기 보다 지금 어떤 형태로 코드가 들어 가는지에 집중하자. 왜냐하면, 최신의 버전은 decision tree가 아니기 때문. 123456from sklearn.datasets import load_irisfrom sklearn import treeclf = tree.DecisionTreeClassifier(random_state=0)iris = load_iris()","link":"/2021/11/04/DecisionTreeClassifier/"},{"title":"Index","text":"GitHub Index made By @YoonHwa-P Python python, Tuple * python, List python, Matplotlib python, Pandas pandas, series pandas, dataframe * python, Numpy python, basic 머신러닝 (의사결정트리) 의사결정트리, Classification 의사결정트리, 이론 python, plotly Kaggle_typical Kaggle_Africa DBS DBS, 이론 논문리뷰, *github girhub, nodjs github, 카테고리 github, Multi jupyterExport(.MD만들기) github, blog 만들기 github, Repository 만들기 올려야 하는 Posting List 의사결정트리, Regression seaborn matplotlib 수정 해야 할것도 넘넘 많다.일단 이번 주 주말에는 Kaggle 먼저 (Team project 닌까.) * : 수정중 123&lt;hr style=&quot;dashed 10px pink;&quot;&gt;&lt;hr align=&quot;center&quot; style=&quot;border: solid 10px #304A84; width: 50%;&quot;&gt;&lt;span style=&quot;font-size:150%; color: Red;&quot;&gt; * &lt;/span&gt; ※ 참고 할 Github ㅁ https://github.com/dschloe/R_edu ㅁ https://github.com/JunghoGIT ㅁ https://github.com/kimgoden/JAVA01 ㅁ https://github.com/WDWDWWDff/Red ㅁ https://github.com/OliverKang ㅁ https://github.com/hanbeen1992 ㅁ https://github.com/kjw1390","link":"/2021/11/05/Index/"},{"title":"How Popular is kaggle in Africa?","text":"1. Introduction1.1 Introduction800 사용자가 사용하고 있는 글로벌 온라인 커뮤니티 케글. 194개의 나라에서 사용중. 2017년부터 머신러닝과 data 과학자들을 대상으로 설문을 했는데, 본 저자는 아프리카 나라들의 참여를 알아보고자 한다. Historical overview 이용 1.2 Table of Contents How does Africa compares with rest of the world? (Region(Q3)) 응답자 수(Africa/전체, 2021): bar-H (Region(Q3)) Africa에서 kgg사용증가 : bar Which African countries are kaggle-aware? (Q3) kgg을 사용하는 Africa나라 (2021): plotly_choroplethMap (Q3) kgg 사옹 증가 나라별 in Africa : heatmap (Q3) 조사에 참여한 나라 비율 in Africa (2021): Pie-Chart(donut) Demography : Age and Gender (Q1) age / (Q2) gender (Africa/전체, 2021): bar /bar-H (Q2, Q2, Q2, Q1, Genderselect) African 여성 비율 : bar Education, Jobs and Experience (Q4)학력/ (Q5)직업/ (Q6)경력 (Africa/전체, 2021): bar-H Programming Languages &amp; IDE’s (Q7-13)프로그래밍 언어 선호 (Africa/전체, 2021): heatmap (Q9-13)IDE (Africa/전체, 2021): bar-H (Q8)추천 프로그래밍 언어 (Africa/전체, 2021): bar-H Machine Learning: Experience, Framework and Algorithms (Q15)Muchine Learning 경력 (Africa/전체, 2021): bar-H (Q16-18)Muchine Learning 플랫폼 (Africa/전체, 2021): bar-H (Q17-12)Muchine Learning 알고리즘 (Africa/전체, 2021): bar-H (Q18-7)computer vision Methods (Africa/전체, 2021): Heatmap (Q19-6)자연언어 처리방법 (Africa/전체, 2021): Heatmap (Q14-12)visualizations Library (Africa/전체, 2021): Heatmap Computing Resources (Q11)hardware platform (Africa/전체, 2021): bar-H (Q13)TPU 사용빈도 (Africa/전체, 2021): bar-H (Q12-6)특별한 하드웨어 (Africa/전체, 2021): Heatmap (Q27_A 12)온라인 플렛폼 (Africa/전체, 2021): bar-H (Q28)클라우드 플렛폼 (Africa/전체, 2021): bar-H (29_A, 5)클라우드 만들때 쓰는 기본 resource? (Africa/전체, 2021): bar-H (32_A, 12빅데이터 만들때 (Africa/전체, 2021): bar-H (Q33)가장많이 쓰는 big data 생성 프로그램 (Africa/전체, 2021): bar-H Employment and role at work (Q20) 최근 고용주 (Africa/전체, 2021): bar-H (Q24)일할때 중요한 활동 (Africa/전체, 2021): Heatmap (Q25) 급여 피라미드 (Africa/전체, 2021): dual bar-H Learning Platform and Media (Q40) data science 배우는 플랫폼 (Africa/전체, 2021): bar-H (Q42-12) 가장 좋아하는 DS Topics 미디어 소스 (Africa/전체, 2021): Heatmap Summary Reference 특정 연도를 넣지 않은 부분은 historical data 2. Import2.1 dataFrame &amp; visualization Module1234import numpy as npimport pandas as pdimport seaborn as snsimport matplotlib.pylab as plt Numpy dataframe Pandas dataframe seabornSeaborn은 Metplotlib를 기본으로 생상테마와 통계용 차트 기능을 추가한 시각화 패키지 기본적인 시각화 기능은 Matplotlib, 통계는 Statsmodels에 의존한다. Ref. seaborn tutorial/En matplotlibmatplotlib.pyplot 모듈은 명령어 스타일로 동작하는 함수의 Library. 함수를 이용하여 그래프를 만들고, grid를 조정하고, Label도 꾸미는 등을 할 수 있다. Ref. matplotlib.pyplot 2.2 plotly1234567891011121314import plotly.io as pioimport plotly.express as pximport plotly.graph_objects as goimport plotly.figure_factory as fffrom plotly.subplots import make_subplots #특정한 차트를 만들기 위해 넣어줌from plotly.offline import init_notebook_mode, iplot #offLine에서도 돌아갈 수 있게 해줌init_notebook_mode(connected=True)pio.templates.default = &quot;none&quot;# import plotly.offline as py# py.offline.init_notebook_mode() Plotlyplotly Livrary 전체를 pio로 받아옴.그 중에서 px : plotly-express go : graph_objects ff : figure_factory px가 존재하기 이전 go로 생성하기 어려운 특정 유형의 플롯을 생성 할 수 있는 전용 함수가 있다. 를 받아 왔다. plotly에서 G를 그리는 방법은 2가지가 있는다. px : 템플릿을 통해 제작 go : 그래프를 하나하나 설정하며 제작 plotly_python plolty-tutorial-guide/Ko offline plotly offline plotly 1234567import osfor dirname, _, filenames in os.walk('/kaggle/input'): for filename in filenames: print(os.path.join(dirname, filename))import warningswarnings.filterwarnings(&quot;ignore&quot;) data input 하는 방법.여러개의 csv file을 경로를 지정 해주어 한번에 넣어주는 code 12345df17= pd.read_csv(&quot;/kaggle/input/kaggle-survey-2017/multipleChoiceResponses.csv&quot;, encoding=&quot;ISO-8859-1&quot;)df18= pd.read_csv(&quot;/kaggle/input/kaggle-survey-2018/multipleChoiceResponses.csv&quot;, )df19= pd.read_csv(&quot;/kaggle/input/kaggle-survey-2019/multiple_choice_responses.csv&quot;, )df20= pd.read_csv(&quot;/kaggle/input/kaggle-survey-2020/kaggle_survey_2020_responses.csv&quot;, )df21= pd.read_csv(&quot;/kaggle/input/kaggle-survey-2021/kaggle_survey_2021_responses.csv&quot;, ) 연도 별로 dataFrame을 씌워서 csv file을 dfyy객체에 Loading해 준다.","link":"/2021/11/10/Kgg_Africa/"},{"title":"kaggle in Africa_Fig","text":"1. IntroductionHelper functions 1.1 horizontal bar graphsGraph의 code 의 경우 해당 data와 연동해서 한꺼번에 보기로 한다. &lt; plot의 종류 &gt; plotly_hBar (df, q, title, height=400,l=250,r=50,b=50,t=100,) plotly_vBar(df, q, title, l=50,r=50,b=50,t=100) head_count(df, question_num, parts): head_count function copied from df_with_percentages(df, q, n, region) plot_barH_percent(df1, df2, title, l=150, r=50, b=50, t=100) annotated_heatmap(df_w, df_a, title, width=850) categorical_scatter(df1, df2, title, l=150, r=50, b=50, t=100) annotated_heatmap_Trans(df_w, df_a, title, width=850, height=750, l=150) head_count_suf(df, question_num, part, n) df_with_percentages_suf(df, q, part, n, region) 위의 코드의 경우 쓰여지지 않은 코드도 있는 것 같지만, 일단 List UP 해 놓음. 1.2 grouping african countries1.2.1 연도 별 Africa 국가 이름 df123456africa17 = ['Nigeria','Kenya', 'South Africa', 'Egypt']africa18 = ['Nigeria','Kenya', 'South Africa', 'Egypt', 'Tunisia', 'Morocco'] africa19 = ['Nigeria','Kenya', 'South Africa', 'Egypt', 'Tunisia', 'Morocco', 'Algeria']africa20 = ['Nigeria','Kenya', 'South Africa', 'Egypt', 'Tunisia', 'Morocco', 'Ghana']africa21 = ['Nigeria','Kenya', 'South Africa', 'Egypt', 'Tunisia', 'Morocco', 'Algeria', 'Ghana', 'Uganda', 'Ethiopia'] 아마도 직접 수기로 찾은 것 같다. 1.2.2 국가 이름 확인 pd.isin(): List에 존재하는 요소가 대상 dataFrame, series에 존재 여부를 Boolean type으로 반환. 123456789101112131415161718192021africa = ['Nigeria', 'Egypt', 'South Africa', 'Algeria', 'Tunisia', 'Morocco', 'Kenya', 'Uganda', 'Ghana', 'Ethiopia']df21_africa = df21[df21['Q3'].isin(africa)]df21_world = df21[~df21['Q3'].isin(africa )]df21['region']=[&quot;Africa&quot; if x in africa else &quot;World&quot; for x in df21['Q3']]df20_africa = df20[df20['Q3'].isin(africa)]df20_world = df20[~df20['Q3'].isin(africa )]df20['region']=[&quot;Africa&quot; if x in africa else &quot;World&quot; for x in df20['Q3']]df19_africa = df19[df19['Q3'].isin(africa)]df19_world = df19[~df19['Q3'].isin(africa)]df19['region']=[&quot;Africa&quot; if x in africa else &quot;World&quot; for x in df19['Q3']]df18_africa = df18[df18['Q3'].isin(africa)]df18_world = df18[~df18['Q3'].isin(africa)]df18['region']=[&quot;Africa&quot; if x in africa else &quot;World&quot; for x in df18['Q3']]df17_africa = df17[df17['Country'].isin(africa)]df17_world = df17[~df17['Country'].isin(africa )]df17['region']=[&quot;Africa&quot; if x in africa else &quot;World&quot; for x in df17['Country']] ‘africa’라는 배열을 만들어 df를 새로 정의 17’~21’까지 같은 내용이므로 21’의 내용만으로 정리 0&gt; df21 data 확인 1&gt; df21[‘Q3’]의 내용은 당신의 나라는 어디 입니까? 2&gt; 따라서 “ df21[‘Q3’].isin(africa) “ 코드의 의미는 Q3의 대답이 africa 이면 True 반환. 3&gt; 결론적으로 Q3의 대답이 Africa[]인 모든 대답을 추출 하게 된다. 4&gt; 반대로 dfworld의 경우 ~ ( not )을 사용하여 Q3이 false인 data frame을 추출 할 수 있는것. 1.2.3 region column을 추가1df21['region']=[&quot;Africa&quot; if x in africa else &quot;World&quot; for x in df21['Q3']] df21 dataframe에 Region이라는 column 을 추가해 보자. region 컬럼에 들어갈 값은 List의 끝까지 반복하되, 만약 df21[‘Q3’]의 값이 africa에 해당하면 “Africa”, 그 밖의 경우는 world를 입력해라. data science를 잘 하려면, python 문법도 잘 알아야 할 듯.","link":"/2021/11/10/Kgg_Africa_Fig/"},{"title":"kaggle in Africa_barH(1-1)","text":"1. Figure Helper functionsKgg_Africa 에서는 python 문법 중에서 함수를 만드는 def 을 이용하여 plot들을 정의 해 놓았다. def 함수명(매개변수): &lt;수행할 문장1&gt; &lt;수행할 문장2&gt; ... ref. python_Function/Ko. 1.1 horizontal bar graphs다음 results plot 을 뜯어보며 bar-H를 해석 해 보자. How does Africa compares with rest of the world? (Region(Q3)) 응답자 수(Africa/전체, 2021): bar-H 먼저, hBar는 다음과 같이 정의 되었다. 그동암 bar-H에대한 많은 부분을 공부 했으므로 간단히 함수를 중심으로 뜯어 보자. plotly.express.histogram 12345678910111213141516171819202122232425262728293031323334353637383940414243def plotly_hBar(df, q, title, height=400,l=250,r=50,b=50,t=100,): fig = px.histogram(df.iloc[1:], y=q, orientation='h', width=700, height=height, histnorm='percent', color='region', color_discrete_map={ &quot;Africa&quot;: &quot;gold&quot;, &quot;World&quot;: &quot;salmon&quot; }, opacity=0.6 ) fig.update_layout(title=title, font_family=&quot;San Serif&quot;, bargap=0.2, barmode='group', titlefont={'size': 28}, paper_bgcolor='#F5F5F5', plot_bgcolor='#F5F5F5', legend=dict( orientation=&quot;v&quot;, y=1, yanchor=&quot;top&quot;, x=1.250, xanchor=&quot;right&quot;,) ).update_yaxes(categoryorder='total ascending') fig.update_traces(marker_line_color='black', marker_line_width=1.5) fig.update_layout(yaxis_title=None,yaxis_linewidth=2.5, autosize=False, margin=dict( l=l, r=r, b=b, t=t, ), ) fig.update_xaxes(showgrid=False) fig.update_yaxes(showgrid=False) fig.show() def plotly_hBar(df, q, title, height=400,l=250,r=50,b=50,t=100,) 함수 plotly_hBar의 정의 df, q, title등의 변수를 선언하고 값을 정해줌. fig 정의 123456789101112fig = px.histogram(df.iloc[1:], y=q, orientation='h', width=700, height=height, histnorm='percent', color='region', color_discrete_map={ &quot;Africa&quot;: &quot;gold&quot;, &quot;World&quot;: &quot;salmon&quot; }, opacity=0.6 ) plotly.express.histogram() plotly의 express Library를 이용하여 histogram을 그려본다. df.iloc[1:] dataframe으로 iloc을 이용하여 컬럼을 가져옴 1행에서부터 끝까지 y= q, 나중에 q변수만 정해서 넣어주면 G가 그려진다. orientation= ‘h’, orientation이 h일땐, x orientation이 v일땐, y 를 하라고 공식문서에 써있는데 왜 얘는 이랬는지 알 수 없음 + Histogram plot 자체가 말이 안됨. height = ‘height’, plot의 높이 지정 height=400이라고 함수 정의때 이미 지정 됨. color = ‘region’, 색은 region이라는 변수가 어떤것이냐에 따라 달라짐 color_discrete_map={“Africa”: “gold”, “World”: “salmon”}, dictionary처럼 Indexing 해 줌. opacity = 0.6 불 투명함의 정도 (0~1, flot) color_discrete_map 과 color_discrete_sequence 의 차이 dict with str keys and str values (default {}) , (list of str) plotly.express","link":"/2021/11/10/Kgg_Africa_bar-H/"},{"title":"kaggle :HorizontalBar (Q7)","text":"kaggle dictation (06) plotly.graph_objects as go: 를 이용한 bar graphHorizontalBar plot /가로 막대 차트0. data sethttps://www.kaggle.com/miguelfzzz/the-typical-kaggle-data-scientist-in-2021 Subject : 가장 많이쓰는 programming 언어_Horizontal bar1. data 읽어오기 Q7에는 sub가 많기 때문에 python 구문을 이용하여‘Q7’ 이 붙어있는 컬럼 불러오기. languages_cols = [col for col in df if col.startswith(‘Q7’)] col 1부터 df 끝까지 Q7로 시작하는지 확인하여 true 일 때만 데이터 가져오기 1languages_cols = [col for col in df if col.startswith('Q7')] 2. data Frame 만들어 주기algorithms 에 data frame을 씌워서 표를 만들고, 이름을 다음과같이 바꿔줌. 12345languages = df[languages_cols]languages.columns = ['Python', 'R', 'SQL', 'C', 'C++', 'Java', 'Javascript', 'Julia', 'Swift', 'Bash', 'MATLAB', 'None', 'Other'] 3.표 설정.12345678languages = ( languages .count() .to_frame() .reset_index() .rename(columns={'index':'Languages', 0:'Count'}) .sort_values(by=['Count'], ascending=False) ) .count() :coulumn 수 세기 .to_frame() : frame 생성 .reset_index() : 원본과 상관없는 Index 생성 .rename() columns의 이름을 지정 : ‘index’:’Languages’, 0:’Count’ .sort_values() by=[‘Count’], ascending=False Count 기준으로 내림차순으로 정렬 3. percent 추가1languages['percent'] = ((languages['Count'] / len(df))*100).round(2).astype(str) + '%' 표에 ‘percent’를 추가algorithms의 count에 df의 length로 나누고 *100을 하는 전형적인 % 나타내기 값자체에 %를 입력하여 나중에 %를 추가 입력하지 않아도 됨 소숫점 자리 2까지 반영(반올림).type 자체를 String으로 하여 추가 계산은 불가능. 4. 색 지정1234567891011colors = ['#033351',] * 13colors[0] = '#5abbf9'colors[1] = '#5abbf9'colors[2] = '#0779c3'colors[3] = '#0779c3'colors[4] = '#0779c3'colors[5] = '#0779c3'colors[6] = '#0779c3'colors[7] = '#05568a'colors[8] = '#05568a'colors[9] = '#05568a' 5. bar Graph 만들기1234567fig = go.Figure(go.Bar( x=algorithms['Count'], y=algorithms['Algorithms'], text=algorithms['percent'], orientation='h', marker_color=colors )) horizontal과 vertical Graph의 차이는 x, y axis를 바꾸어 주는 것과 orientation=’h’ 을 넣어 주는 것의 차이. 6. update_traces()traces() 수정 : Trace에 대한 설정 123456fig.update_traces(texttemplate='%{text}', textposition='outside', cliponaxis = False, hovertemplate='&lt;b&gt;Lenguage&lt;/b&gt;: %{y}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;'+ '&lt;b&gt;Count&lt;/b&gt;: %{x}', textfont_size=12) texttemplate : text type textposition : ‘outside’ _ 설정 해 주지 않은 경우 칸에 따라 적당히 들어감. cliponaxis = False : text가 칸이 작아서 짤리는 경우를 막아주는 기능 (off) hovertemplate : 마우스 On하면 (커서를 위에 대면) 나오는 Hovert에대한 설정. textfont_size : 폰트 size 7. Design1234567891011121314151617fig.update_xaxes(showgrid=False)fig.update_yaxes(showgrid=False)fig.update_layout(showlegend=False, plot_bgcolor='#F7F7F7', margin=dict(pad=20), paper_bgcolor='#F7F7F7', height=700, xaxis={'showticklabels': False}, yaxis_title=None, xaxis_title=None, yaxis={'categoryorder':'total ascending'}, title_text=&quot;Most Commonly Used &lt;b&gt;Programming Languages&lt;/b&gt;&quot;, title_x=0.5, font=dict(family=&quot;Hiragino Kaku Gothic Pro, sans-serif&quot;, size=17, color='#000000'), title_font_size=35) Grid Delete update_layout showlegend=False, plot_bgcolor=’#F7F7F7’ margin=dict(pad=20), paper_bgcolor=’#F7F7F7’, xaxis={‘showticklabels’: False}, x 축 labels을 삭제. yaxis_title=None, xaxis_title=None, yaxis={‘categoryorder’:’total ascending’}, y 축 title을 categoryorder : 정렬 title_text=”Most Commonly Used Algorithms“, title_x=0.5, font=dict(family=”Hiragino Kaku Gothic Pro, sans-serif”, size=15, color=’#000000’), title_font_size=35) 8. Annotation12345678910111213141516171819fig.add_annotation(dict(font=dict(size=14), x=0.98, y=-0.13, showarrow=False, text=&quot;@miguelfzzz&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;))fig.add_annotation(dict(font=dict(size=12), x=0, y=-0.13, showarrow=False, text=&quot;Source: 2021 Kaggle Machine Learning &amp; Data Science Survey&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;))fig.show()","link":"/2021/11/09/Kgg_plotly_Bar_H(3)/"},{"title":"kaggle :HorizontalBar (Q9)","text":"kaggle dictation (04) plotly.graph_objects as go: 를 이용한 bar graphHorizontalBar plot /가로 막대 차트0. data sethttps://www.kaggle.com/miguelfzzz/the-typical-kaggle-data-scientist-in-2021 Subject : 어떤알고리즘을 선호 하는 지 알아보는 Horizontal bar1. data 읽어오기123456# Features that start with Q7ide_cols = [col for col in df if col.startswith('Q9')]ide = df[ide_cols]print(ide) list comprehensionfor문으로 돌린 data값을 전부 col로 받아와서그 값을 또 ide_cols에 싣는 한줄로 이루어진 코드. 2. data Frame 만들어 주기ide를 dataframe화 완료. 123ide.columns = ['JupyterLab', 'RStudio', 'Visual Studio', 'VSCode', 'PyCharm', 'Spyder', 'Notepad++', 'Sublime Text', 'Vim, Emacs, or similar', 'MATLAB', 'Jupyter Notebook', 'None', 'Other'] Q9의 column이름 재 설정. 3.표 설정.1234567891011ide = ( ide .count() .to_frame() .reset_index() .rename(columns={'index':'IDE', 0:'Count'}) .sort_values(by=['Count'], ascending=False) )ide['percent'] = ((ide['Count'] / len(df))*100).round(2).astype(str) + '%' 3. percent 추가1ide['percent'] = ((ide['Count'] / len(df))*100).round(2).astype(str) + '%' 4. 색 지정123456789colors = ['#033351',] * 13colors[0] = '#5abbf9'colors[1] = '#5abbf9'colors[2] = '#0779c3'colors[3] = '#0779c3'colors[4] = '#0779c3'colors[5] = '#0779c3'colors[6] = '#0779c3'colors[7] = '#0779c3' 5. bar Graph 만들기1234567fig = go.Figure(go.Bar( x=ide['Count'], y=ide['IDE'], text=ide['percent'], orientation='h', marker_color=colors )) 6. update_traces()123456fig.update_traces(texttemplate='%{text}', textposition='outside', cliponaxis = False, hovertemplate='&lt;b&gt;IDE&lt;/b&gt;: %{y}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;'+ '&lt;b&gt;Count&lt;/b&gt;: %{x}', textfont_size=12) 7. Design12345678910111213141516fig.update_xaxes(showgrid=False)fig.update_yaxes(showgrid=False) fig.update_layout(showlegend=False, plot_bgcolor='#F7F7F7', margin=dict(pad=20), paper_bgcolor='#F7F7F7', xaxis={'showticklabels': False}, yaxis_title=None, height = 600, xaxis_title=None, yaxis={'categoryorder':'total ascending'}, title_text=&quot;Most Commonly Used &lt;b&gt;IDE's&lt;/b&gt;&quot;, title_x=0.5, font=dict(family=&quot;Hiragino Kaku Gothic Pro, sans-serif&quot;, size=15, color='#000000'), title_font_size=35) 8. Annotation1234567891011121314151617181920fig.add_annotation(dict(font=dict(size=14), x=0.98, y=-0.17, showarrow=False, text=&quot;@miguelfzzz&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;))fig.add_annotation(dict(font=dict(size=12), x=0, y=-0.17, showarrow=False, text=&quot;Source: 2021 Kaggle Machine Learning &amp; Data Science Survey&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;))fig.show()","link":"/2021/11/09/Kgg_plotly_HZB(2)/"},{"title":"kaggle :HorizontalBar (Q17)","text":"kaggle dictation (03) plotly.graph_objects as go: 를 이용한 bar graphHorizontalBar plot /가로 막대 차트0. data sethttps://www.kaggle.com/miguelfzzz/the-typical-kaggle-data-scientist-in-2021 Subject : 어떤알고리즘을 선호 하는 지 알아보는 Horizontal bar1. data 읽어오기algorithms_cols에 data frame을 먼저 만들고 시작.잘 모르겠지만 아마도 Q17이 붙은 data를 선택 하기 위한 code algorithms_cols = [col for col in df if col.startswith(‘Q17’)] col 1부터 df 끝까지 Q17로 시작하는지 확인하여 true일때만 데이터 가져오기 ref. How to select dataframe columns that start with *** using pandas in python ? 12algorithms_cols = [col for col in df if col.startswith('Q17')] 2. data Frame 만들어 주기algorithms 에 data frame을 씌워서 표를 만들고, 이름을 다음과같이 바꿔줌. 12345678algorithms = df[algorithms_cols]algorithms.columns = ['Linear or Logistic Regression', 'Decision Trees or Random Forests', 'Gradient Boosting Machines', 'Bayesian Approaches', 'Evolutionary Approaches', 'Dense Neural Networks', 'Convolutional Neural Networks', 'Generative Adversarial Networks', 'Recurrent Neural Networks', 'Transformer Networks', 'None', 'Other'] 3.표 설정.12345678algorithms = ( algorithms .count() .to_frame() .reset_index() .rename(columns={'index':'Algorithms', 0:'Count'}) .sort_values(by=['Count'], ascending=False) ) .count() :coulumn 수 세기 .to_frame() : frame 생성 .reset_index() : 원본과 상관없는 Index 생성 .rename() columns의 이름을 지정 : ‘index’:’Algorithms’, 0:’Count’ .sort_values() by=[‘Count’], ascending=False Count 기준으로 내림차순으로 정렬 3. percent 추가12algorithms['percent'] = ((algorithms['Count'] / len(df))*100).round(2).astype(str) + '%' 표에 ‘percent’를 추가algorithms의 count에 df의 length로 나누고 *100을 하는 전형적인 % 나타내기 값자체에 %를 입력하여 나중에 %를 추가 입력하지 않아도 됨 소숫점 자리 2까지 반영(반올림).type 자체를 String으로 하여 추가 계산은 불가능. 4. 색 지정12345678colors = ['#033351',] * 12colors[0] = '#5abbf9'colors[1] = '#5abbf9'colors[2] = '#066eb0'colors[3] = '#066eb0'colors[4] = '#044a77'colors[5] = '#044a77'colors[6] = '#044a77' 색 깊이는 12단계, 0~6까지는 정해주고 나머지 5개는 #033351을 default로 한 것을 알 수 있다. 5. bar Graph 만들기1234567fig = go.Figure(go.Bar( x=algorithms['Count'], y=algorithms['Algorithms'], text=algorithms['percent'], orientation='h', marker_color=colors )) horizontal과 vertical Graph의 차이는 x, y axis를 바꾸어 주는 것과 orientation=’h’ 을 넣어 주는 것의 차이. &lt;orientation 없음&gt; &lt;orientation H 있음&gt; 6. update_traces()traces() 수정 : Trace에 대한 설정 123456fig.update_traces(texttemplate='%{text}', textposition='outside', cliponaxis = False, hovertemplate='&lt;b&gt;Algorithm&lt;/b&gt;: %{y}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;'+ '&lt;b&gt;Count&lt;/b&gt;: %{x}', textfont_size=12) texttemplate : text type textposition : ‘outside’ _ 설정 해 주지 않은 경우 칸에 따라 적당히 들어감. cliponaxis = False : text가 칸이 작아서 짤리는 경우를 막아주는 기능 (off) hovertemplate : 마우스 On하면 (커서를 위에 대면) 나오는 Hovert에대한 설정. textfont_size : 폰트 size 7. Design1234567891011121314151617fig.update_xaxes(showgrid=False)fig.update_yaxes(showgrid=False)fig.update_layout(showlegend=False, plot_bgcolor='#F7F7F7', margin=dict(pad=20), paper_bgcolor='#F7F7F7', xaxis={'showticklabels': False}, yaxis_title=None, height = 600, xaxis_title=None, yaxis={'categoryorder':'total ascending'}, title_text=&quot;Most Commonly Used &lt;b&gt;Algorithms&lt;/b&gt;&quot;, title_x=0.5, font=dict(family=&quot;Hiragino Kaku Gothic Pro, sans-serif&quot;, size=15, color='#000000'), title_font_size=35) Grid Delete update_layout showlegend=False, plot_bgcolor=’#F7F7F7’ margin=dict(pad=20), paper_bgcolor=’#F7F7F7’, xaxis={‘showticklabels’: False}, x 축 labels을 삭제. yaxis_title=None, xaxis_title=None, yaxis={‘categoryorder’:’total ascending’}, y 축 title을 categoryorder Automatically Sorting Categories by Name or Total Value layout-xaxis-categoryorder title_text=”Most Commonly Used Algorithms“, title_x=0.5, font=dict(family=”Hiragino Kaku Gothic Pro, sans-serif”, size=15, color=’#000000’), title_font_size=35) 이미 앞서서 충분히 설명 했기 때문에 본 posting에서 설명되지 않은 부분은 basic bar Graph 에서 확인 8. Annotation1234567891011121314151617181920fig.add_annotation(dict(font=dict(size=14), x=0.98, y=-0.17, showarrow=False, text=&quot;@miguelfzzz&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;))fig.add_annotation(dict(font=dict(size=12), x=0, y=-0.17, showarrow=False, text=&quot;Source: 2021 Kaggle Machine Learning &amp; Data Science Survey&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;))fig.show()","link":"/2021/11/09/Kgg_plotly_Horizontal/"},{"title":"kaggle :ScatterLine (Q42)","text":"kaggle dictation (08) plotly.graph_objects as go_ Scatter + line plot산점도 bivariate”이변수” 값을 시각화 하는 기본적인 그래프. correlation: Positive, Negative, non 두 개의 변수 각각의 분포과 변수간의 관계를 확인 할 수 있다. ref. line-and-scatter/En. Q11_Scatter 0. data sethttps://www.kaggle.com/miguelfzzz/the-typical-kaggle-data-scientist-in-2021 Subject : 가장 많이 이용하는 Media source1. data 읽어오기Q42로 시작하는 col을 읽어오기.python의 for문을 이용. 1media_cols = [col for col in df if col.startswith('Q42')] 2. data Frame 만들어 주기123456media = df[media_cols]media.columns = ['Twitter', 'Email newsletters', 'Reddit', 'Kaggle', 'Course Forums', 'YouTube', 'Podcasts', 'Blogs', 'Journal Publications', 'Slack Communities', 'None', 'Other'] 3.표 설정.12345678910media = ( media .count() .to_frame() .reset_index() .rename(columns={'index':'Medias', 0:'Count'}) .sort_values(by=['Count'], ascending=False) )media 4. 색 지정12345678910colors = ['#033351',] * 12colors[11] = '#5abbf9'colors[10] = '#5abbf9'colors[9] = '#5abbf9'colors[8] = '#0779c3'colors[7] = '#0779c3'colors[6] = '#0779c3'colors[5] = '#0779c3'colors[4] = '#0779c3' 5. percent로 계산한 column 추가i. add percent column 123media['percent'] = ((media['Count'] / len(df))*100).round(2).astype(str) + '%'media ii. Count값 (column값으로 ) 정렬 123456media = (media .sort_values(by = ['Count']) .iloc[0:15] .reset_index())media 1. Default는 내림차순 2. iloc으로 0번부터 15까지 List로 긁어오기 3. reset index() 6.plotly.graph_objects.Scatter()Scatter G 그리기 i. 산점도 점 찍기 12345678fig = go.Figure(go.Scatter(x = media['Count'], y = media[&quot;Medias&quot;], text = media['percent'], mode = 'markers', marker_color =colors, marker_size = 12))fig ii. 산점도에 for문을 이용하여 line 연결하기 1234567for i in range(0, len(media)): fig.add_shape(type='line', x0 = 0, y0 = i, x1 = media[&quot;Count&quot;][i], y1 = i, line=dict(color=colors[i], width = 4)) fig for i in range(0~platform의 길이만큼) fig. add_shape() type = ‘line’ line모양의 grape shape add x0 = 0, y0 = i, 초기값 (0, i)에서 시작 (0, 0) = other Line Start x1 = platform[“Count”][i], x축 Index : count의 값만큼 x축방향으로 Line이 그어진다. y1 = i, y축 Index, 마지막 값 line=dict(color=colors[i], width = 4) line의 세부 설정, 색과 두께 7. update_traces(hovertemplate)123fig.update_traces(hovertemplate='&lt;b&gt;Media Source&lt;/b&gt;: %{y}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;'+ '&lt;b&gt;Count&lt;/b&gt;: %{x}&lt;br&gt;'+ '&lt;b&gt;Proportion&lt;/b&gt;: %{text}') 8. Designi. 축 grid 12fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='#9f9f9f', ticklabelmode='period')fig.update_yaxes(showgrid=False) x 축의 grid만 보여줌. tick labe lmode : period plotly의 axes/En ii. update_layout() 123456789101112fig.update_layout(showlegend=False, plot_bgcolor='#F7F7F7', margin=dict(pad=20), paper_bgcolor='#F7F7F7', yaxis_title=None, xaxis_title=None, title_text=&quot;Most Commonly Used &lt;b&gt;Media Sources&lt;/b&gt;&quot;, title_x=0.5, height=700, font=dict(family=&quot;Hiragino Kaku Gothic Pro, sans-serif&quot;, size=17, color='#000000'), title_font_size=35) 9. Annotation12345678910111213141516171819fig.add_annotation(dict(font=dict(size=14), x=0.98, y=-0.22, showarrow=False, text=&quot;@miguelfzzz&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;))fig.add_annotation(dict(font=dict(size=12), x=0.04, y=-0.22, showarrow=False, text=&quot;Source: 2021 Kaggle Machine Learning &amp; Data Science Survey&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;))fig.show()","link":"/2021/11/09/Kgg_plotly_ScatterL(2)/"},{"title":"kaggle :ScatterLine (Q11)","text":"kaggle dictation (05) plotly.graph_objects as go: 를 이용한 Scatter + line G산점도 bivariate”이변수” 값을 시각화 하는 기본적인 그래프. correlation: Positive, Negative, non 두 개의 변수 각각의 분포과 변수간의 관계를 확인 할 수 있다. ref. box and scatter plot/Ko.통계 그리는 방법 0. data sethttps://www.kaggle.com/miguelfzzz/the-typical-kaggle-data-scientist-in-2021 Subject : 가장 많이 이용하는 computer platform(hardware)1. data 읽어오기 + data Frame 만들어 주기1234567891011platform = ( df['Q11'] .value_counts() .to_frame() .reset_index() .rename(columns={'index':'Platform', 'Q11':'Count'}) .sort_values(by=['Count'], ascending=False) .replace(['A deep learning workstation (NVIDIA GTX, LambdaLabs, etc)', 'A cloud computing platform (AWS, Azure, GCP, hosted notebooks, etc)'], ['A deep learning workstation', 'A cloud computing platform']) ) ide를 dataframe화 완료. Q11의 column이름 까지 재설정 완료. 2.표 설정.1234567891011ide = ( ide .count() .to_frame() .reset_index() .rename(columns={'index':'IDE', 0:'Count'}) .sort_values(by=['Count'], ascending=False) )ide['percent'] = ((ide['Count'] / len(df))*100).round(2).astype(str) + '%' 3. percent 추가1platform['percent'] = ((platform['Count'] / platform['Count'].sum())*100).round(2).astype(str) + '%' 3. 색 지정1234colors = ['#033351',] * 6colors[5] = '#5abbf9'colors[4] = '#0779c3'colors[3] = '#0779c3' 4. 표 재 설정12345platform = (platform .sort_values(by = ['Count']) .iloc[0:15] .reset_index())platform .sort_values(by = [‘Count’]) : [Count]로 정렬, .iloc[0:15] platform의 column 선택: 0~15까지 data 가져오기 .reset_index() : data와 상관 없는 새 index 가져오기 5.plotly.graph_objects.Scatter() 본격적으로 Scatter G 만들기. ## 산점도 점 찍기 12345678fig = go.Figure(go.Scatter(x = platform['Count'], y = platform[&quot;Platform&quot;], text = platform['percent'], mode = 'markers', marker_color =colors, marker_size = 12))fig x = platform[‘Count’], y = platform[“Platform”], x축, y축 설정 text = platform[‘percent’], text를 넣는다고 하는데 안보이네 mode = ‘markers’, Text, lines+markers, makers, line 이 가능 한거 같다. Scatter.mod marker_color =colors, marker_size = 12) 산점도 안에 있는 점의 색과 크기 ## 산점도에 for문을 이용하여 line 연결하기 123456for i in range(0, len(platform)): fig.add_shape(type='line', x0 = 0, y0 = i, x1 = platform[&quot;Count&quot;][i], y1 = i, line=dict(color=colors[i], width = 4)) for i in range(0~platform의 길이만큼) fig. add_shape() type = ‘line’ - line모양의 grape shape add x0 = 0, y0 = i, - 초기값 x1 = platform[“Count”][i], x축 Indexy1 = i, y축 Index, 마지막 값 line=dict(color=colors[i], width = 4) line의 세부 설정, 색과 두께 flatform은 .iloc[0:15] 로 뽑아진 list 형식따라서 platform[“Count”][i]값을 뽑아 낼 수 있다. 6. update_traces()123fig.update_traces(hovertemplate='&lt;b&gt;Platform&lt;/b&gt;: %{y}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;'+ '&lt;b&gt;Count&lt;/b&gt;: %{x}&lt;br&gt;'+ '&lt;b&gt;Proportion&lt;/b&gt;: %{text}') 7. Design12345678910111213fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='#9f9f9f', ticklabelmode='period')fig.update_yaxes(showgrid=False) fig.update_layout(showlegend=False, plot_bgcolor='#F7F7F7', margin=dict(pad=20), paper_bgcolor='#F7F7F7', yaxis_title=None, xaxis_title=None, title_text=&quot;Most Commonly Used &lt;b&gt;Computing Platforms&lt;/b&gt;&quot;, title_x=0.5, font=dict(family=&quot;Hiragino Kaku Gothic Pro, sans-serif&quot;, size=17, color='#000000'), title_font_size=35) 8. Annotation12345678910111213141516171819fig.add_annotation(dict(font=dict(size=14), x=0.98, y=-0.22, showarrow=False, text=&quot;@miguelfzzz&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;))fig.add_annotation(dict(font=dict(size=12), x=0.04, y=-0.22, showarrow=False, text=&quot;Source: 2021 Kaggle Machine Learning &amp; Data Science Survey&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;))fig.show()","link":"/2021/11/09/Kgg_plotly_ScatterLine/"},{"title":"kaggle :Bar Graph (Q6)","text":"kaggle dictation (02) plotly.graph_objects as go: 를 이용한 bar graph###bar plot /막대 차트 막대그래프는 가장 많이 쓰이는 플롯들중 하나로 숫자 변수와 범주 형 변수 간의 관계를 보여 줍니다. 막대 차트는 종종 히스토그램과 혼동 되기도 하는데(숫자의 분포를 보여줌) 이는 통계학의 부분 그룹당 여러 값이 있는 경우에는 박스플롯이나 바이올린 플롯을 추천 최소한 그룹당 관측치 수와 각 그룹의 신뢰구간은 표시되야함. 사용한 Library12345678import pandas as pdimport numpy as npimport seaborn as snsimport plotly.express as pximport plotly.graph_objects as goimport warningswarnings.filterwarnings('ignore') 사실 이 부분에서 seaborn을 사용 했는지 잘 모르겠음. github에서 plotly가 동적 Livrary라 자꾸 오류가남. data importdata 원문data import 방법 data: Kaggle의 the-typical-kaggle-data-scientist-in-2021 이 부분은 data import 방법 을 참고 하거나kaggle dictation (01) 을 참조하세요. data encoding (Feature Engineering)사실 이 부분이 feature Engineering에 해당하는 부분인지 잘 모르겠다. 이 부분은 data를 computer로 자동화하여 계산, 동적 그래프를 만들기 위한 부분. ###Feature Engineering Experience라는 Question 6에 해당하는 값을 전처리 해 준다. 123456789101112experience = ( df['Q6'] .value_counts() .to_frame() .reset_index() .rename(columns={'index':'Experience', 'Q6':'Count'}) .replace(['I have never written code','&lt; 1 years', '1-3 years', '3-5 years', '5-10 years', '10-20 years', '20+ years'], ['No experience', '&lt;1 years', '1-3 years', '3-5 years', '5-10 years', '10-20 years', '20+ years']) ) .value_counts() : 데이터의 분포를 확인하는데 매우 유용한 함수 column 값의 개수를 확인 하는것. 중복되는 값을 묶어줌. .to_frame() : frame을 설정 (표 생성) reset_index() 원본 data를 회손하지 않고 Index를 새로 만듦 .rename(columns={‘index’:’Experience’, ‘Q6’:’Count’}) column에 새로운 이름을 붙여줌 index는 Experience로 Q6은 count로 지정 replace() [왼쪽]에 있는 값대신 [오른쪽]에 있는 값을 넣으려고 함. 이 경우 ‘I have never written code’를 ‘No experience’로 바꾸려고 한듯. Ref. 판다스 함수 df.value_counts() 함수만 사용하면 아래와 같이 나온다. 1df['Q6'].value_counts() 1-3 years 7874&lt; 1 years 58813-5 years 40615-10 years 309910-20 years 216620+ years 1860I have never written code 1032Name: Q6, dtype: int64 이는 문자형 data를 분석하여 display하기 위한 방법 data categoircal로 List로 만들고, 함수정의, 정렬(#1) : Pandas lib의 categories function문자열 객체의 배열을 series로 변환하여 범주형으로 변환 1234567#1experience['Experience'] = pd.Categorical( experience['Experience'], ['No experience', '&lt;1 years', '1-3 years', '3-5 years', '5-10 years', '10-20 years', '20+ years'] ) pd.categories (#2) : experience[‘percent’]Experience에 하나의 tap을 추가 해준다.SQL 의 insert 에 percent tep을 만들어 줄 때 column에대해 계산하여 값을 보여주는 것과 같은 느낌. value에 들어갈 수식 지정_ Experience의 percent 계산 123 #2experience['percent'] = ((experience['Count'] / experience['Count'].sum())*100).round(2).astype(str) + '%' (#3) : experience.sort_values()데이터 정렬하기 : 컬럼의 data를 기준으로 정렬 - short_Index의 경우에는 Index를 기준으로 data를 정렬한다. - 이 경우에는 (‘Experience’)를 기준으로 default값인 오름차순으로 정렬 보통 percent나 count를 기준으로 정렬 되는데 이 경우 sort_values(‘Experience’) 를 하였기때문에기준인 Experience를 기준으로 오름차순으로 정렬 되었다. Short_value 123#3experience = experience.sort_values('Experience') (#4) : colors바chart의 color을 설정 *7 은 7개의 수준이 있다는 것. colors[N] = 뭘까 chart color 123456789#4colors = ['#033351',] * 7colors[1] = '#5abbf9'colors[2] = '#5abbf9'colors[3] = '#0779c3'colors[4] = '#0779c3' (#5) : fig = go.Figure(go.Bar())import plotly.graph_objects as go 이기때문에 fig는 plotly library 함수 사용 12345678#5fig = go.Figure(go.Bar( y=experience['Count'], x=experience['Experience'], cliponaxis = False, text=experience['percent'], marker_color=colors )) x축, y축 정해주기 y=experience[‘Count’], x=experience[‘Experience’], cliponaxis cliponaxis = False, cliponaxis – Text node를 아래 축에 고정 할지 아닐지 결정text node를 축 라인과 체크라벨 위에 보여주기위해서는 x축Layer와 y축 layer 설정을 해 주어야 한다. text=experience[‘percent’] marker_color=colors 지정 해 준 colors를 사용. (#6) : fig.update_traces()그래프 위에 캡션 다는 기능 Perform a property update operation on all traces that satisfy the specified selection criteria 지정된 선택 기준을 충족하는 모든 추적에 대해 속성 업데이트 작업 수행 (?? 전혀 모르겠군 !) 아래 본문과는 상관없는 data를 좀 보세요. 12345678910111213141516df1 = df['Q1'].value_counts()df2 = df['Q1'].value_counts(normalize = True)val_pnt_df = pd.DataFrame({&quot;count&quot;:df1,&quot;%&quot;:df2*100})fig = go.Figure()# [str(x) + ' %' for x in np.round(val_pnt_df[&quot;%&quot;].values, 1).tolist()]# Add Tracesfig.add_bar(x = val_pnt_df.index, y = val_pnt_df['count'].values, text = [str(x) + ' %' for x in np.round(val_pnt_df[&quot;%&quot;].values, 1).tolist()], textposition=&quot;auto&quot;)# layoutfig.update_layout(title_text = &quot;Q1. &quot; + questions[1])fig.show() python의 comprehension 오늘은 못보고 나중에 다시 보자 ! 123456#6fig.update_traces(texttemplate='%{text}', textposition='outside', hovertemplate='&lt;b&gt;Experience&lt;/b&gt;: %{x}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;'+ '&lt;b&gt;Count&lt;/b&gt;: %{y}', textfont_size=12) texttemplate=’%{text}’, : text type textposition=’outside’, : inside하면 그래프 안쪽, ouside 하면 그래프 위쪽에 생성 hovertemplate= 커서를 가까이 대면 나오는 창 x값과, y 값이 어떤 상태인지 알려 준다. hevertemplate Returns the Figure object that the method was called on 메서드가 호출된 그림객체를 반환. plotly.graph_objects.Figure.update_traces 123#7fig.update_xaxes(showgrid=False)fig.update_yaxes(showgrid=False) (#7) : fig.update_?axes()만들어진 fig를 수정.SQL의 update와 비슷한 기능인듯. fig.update_xaxes(showgrid=False) : x축의 grid 수정fig.update_yaxes(showgrid=False) : y축의 grid 수정 축을 보이지 않는 형태로 바꾸어 예쁘게 보이게 해줌. (#8) : update_layout()1234567891011121314#8fig.update_layout(showlegend=False, plot_bgcolor='#F7F7F7', margin=dict(pad=20), paper_bgcolor='#F7F7F7', height=500, yaxis={'showticklabels': False}, yaxis_title=None, xaxis_title=None, title_text=&quot;&lt;b&gt;Experience&lt;/b&gt; Distribution&quot;, title_x=0.5, font=dict(family=&quot;Hiragino Kaku Gothic Pro, sans-serif&quot;, size=14, color='#000000'), title_font_size=35) default로 되어있는 그래프의 Layout을 수정. showlegend = False 래전드를 보여줄지 : 안보여줌 plot_bgcolor=’#F7F7F7’ margin=dict(pad=20)-dic에는 여러가지가 올 수 있는데 여기서는 dict(pad)를 사용 padding을 설정, 축과 그래프 사이의 패딩을 px 단위로 설정 Sets the amount of padding (in px) between the plotting area and the axis lines layout-margin paper_bgcolor=’#F7F7F7’ 배경색 설정 height=500 plot size 설정 yaxis={‘showticklabels’: False} y축의 showticklabels 설정 : 안함 yaxis_title=None, xaxis_title=None y축 제목, x축 제목 설정 : 없음 title_text=”Most Recommended Programming Language“ 제목 달기 &lt;b&gt; code는 bolde tag인듯. title_x=0.5, title_y=0.95, 제목의 위치 (상단 고정) font=dict(family=”Hiragino Kaku Gothic Pro, sans-serif”, size=17, color=’#000000’), title_font_size=35) title의 font 설정 (Default: “”Open Sans”, verdana, arial, sans-serif”) font 설정 family, color, size 설정 가능, title_fond도 함께 설정 가능 해 보임. plotly.graph_objects.Figure.update_layout (#9) : add_annotation()annotation의 경우 plot 안에 글을 집어 넣는 것. 설명을 추가 해 준다고 생각하면 쉽다. 어렵지도 않고, 같은 내용이므로 이전 posting을 첨부 annotation 12345678910111213141516171819fig.add_annotation(dict(font=dict(size=14), x=0.98, y=-0.24, showarrow=False, text=&quot;@miguelfzzz&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;))fig.add_annotation(dict(font=dict(size=12), x=-0.03, y=-0.24, showarrow=False, text=&quot;Source: 2021 Kaggle Machine Learning &amp; Data Science Survey&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;))fig.show() ref. plotly.graph_object Parameter var chart in plotly/en","link":"/2021/11/08/Kgg_plotly_bar/"},{"title":"kaggle :Donut Chart Graph (Q2)","text":"","link":"/2021/11/09/Kgg_plotly_pie/"},{"title":"Make a gitHub","text":"학원에서 배운 코드들을 올려봅시다. 깃허브 디자인 더 하고 싶은데 안되넹 흐흐 오늘 한 내용 정리 + slack join (green_702) + anaconda install + system Path (환경변수 설정_자동) + pycham install + gitHub blog 만들기 (회원가입 & repository 생성) + gitHub에 repository 만들고, file UPloading 하기_01 1. gitHub에서 repository 만들기 클릭 2. 이름 red로 설정후 하단에 add a README.file 체크 3. 바탕화면에서 우측클릭후 git bash here 선택 4. 링크로 연결 : git clone https://github.com/각자계정/red.git + gitHub에 repository 만들고, file UPloading 하기_02 1. file 만들기(Blue) 2. GitHub에 repository 만들기(Blue); 이름이 같지 않으면 안됨 3. 원하는 file 넣기 (folder 가능) + git 명령어 + terminal Tap에 Git Bash를 활성화하여 명령어 입력 $ git init >$ git init_ git을 initiation 해 준다. (초기화) ![img.png](..\\imeges\\Make_gitHub\\img.png) 맨 처음에만 해 주면 된다. $ git add . > $ git add : 지금 Update한 data를 서버에 올려준다. ![img_1.png](..\\imeges\\Make_gitHub\\img_1.png) $ git add . : 경로에 있는 모든 file Upload $ git add [filename.Ex] : [file 이름과 확장자] 특정 file 을 저장 $ git commit - m \"Comment(History log)\" > $ git commit - m \"Comment(History log)\" ![img_2.png](..\\imeges\\Make_gitHub\\img_2.png) commit하여 확정 해 준다. 5개의 sql files가 올라간 것을 볼 수 있다. ![img_3.png](..\\imeges\\Make_gitHub\\img_3.png) 확정 해 주고 마지막으로 push 해 주면 다음과같은 History Log를 github main에서 볼 수 있다. $ git status $git status 깃허브 commit 하기 전에 올릴 파일이 있는지 등의 상태를 알아 볼 수 있다. commit 이후에는 사라지나부다 사진이 없다. 올리기 전에 급하게 한컷 찍어 보앗쥐 커밋해야하는 상태를 보여준다. $ git push > $ git push 최종 브라우저에 저장. ![img_4.png](..\\imeges\\Make_gitHub\\img_4.png) $ git push 후 main -> main 이 나오면 성공 ! > Ref. *파이참, 아나콘다 DownLoad ㅁ https://www.anaconda.com/products/individual#Downloads ㅁ https://www.jetbrains.com/pycharm/download/ ㅁ https://git-scm.com/ Ref..https://80000coding.oopy.io/865f4b2a-5198-49e8-a173-0f893a4fed45 ㄴ&gt; 깃허브 꾸미기 ++앞으로 참고 하고 싶은 github++ㅁ https://github.com/dschloe/R_edu ㅁ https://github.com/JunghoGIT ㅁ https://github.com/kimgoden/JAVA01 ㅁ https://github.com/WDWDWWDff/Red ㅁ https://github.com/OliverKang ㅁ https://github.com/hanbeen1992 ㅁ https://github.com/kjw1390","link":"/2021/10/29/Make_gitHub/"},{"title":"Study Numpy","text":"Numpy Numpy 정의NumPy는 행렬이나 일반적으로 대규모 다차원 배열을 쉽게 처리 할 수 있도록 지원하는 파이썬의 라이브러리Numpy는 데이터 구조 외에도 수치 계산을 위해 효율적으로 구현된 기능을 제시 한다. Ref. Wiki 라이브러리에서 numpy 불러오기우리는 numpy를 import 하여 numpy에 내장되어 있는 함수를 가져와 쓸 수 있다. 일반적으로 np에 저장하여 많이 사용 하는 듯 하다. 123456789import numpy as npprint(np.__version__)print (&quot;Numpy의 version을 확인 해 볼 수 있다. &quot;)temp = np.array([1, 2, 3])print(type(temp))print (&quot;Numpy의 type은 nd array인 것을 볼 수 있다. &quot;) 1.19.5 Numpy의 version을 확인 해 볼 수 있다. &lt;class 'numpy.ndarray'&gt; Numpy의 Type을 보면 nd array 인 것을 볼 수 있는데 ND : N dimension 을 의미한다.즉 한국어로 번역 해 보면 N차 행렬 정도로 볼 수 있다. Numpy 에서 배열을 생성 해 보자.1차원 배열 생성1차원의 배열을 생성해서 array와 List의 다른 점을 알아보자. 차이점은 shpae를 찍어 보면 알 수 있다.내장 함수 : (fuction or method or attribute) 123456789101112131415161718data1 = [0, 1, 2, 3, 4]data2 = [10, 9, 8, 7, 6]My_array = np.array(data1)print(&quot;data1은 List이다. &quot;)print(data1)print(type(data1))#print(data1.shape) #List의 경우 shape 함수가 내장 되어 있지 않아 shape를 알 수 없다. print(&quot;My_array은 numpy형식의 tuple인 것을 알 수 있다. &quot;)print(My_array)print(My_array.shape)print(type(My_array))print(&quot;.dtype() 는 data의 type을 확인 할 수 있는 function 이다.&quot;)print(My_array.dtype) data1은 List이다. [0, 1, 2, 3, 4] &lt;class 'list'&gt; My_array은 numpy형식의 tuple인 것을 알 수 있다. [0 1 2 3 4] (5,) &lt;class 'numpy.ndarray'&gt; .dtype() 는 data의 type을 확인 할 수 있는 function 이다. int64 List 형식의 경우 shape 함수가 내장 되어 있지 않은 반면,numpy 형식의 np.array 의 경우 tuple shape 함수가 내장 되어 에러가 나지 않과 (5, )의 형태로 result가 나오는 것 을 볼 수 있다. .dtype() 는 data의 type을 확인 할 수 있는 function 이다.이때 나타나는 int 64는 64byte의 타입 이라는 것을 알려 준다. https://rfriend.tistory.com/285 2차원 배열 생성4 X 3 배열을 만들어 보자. 1234my_array4 = np.array([[2,4,6],[8,10,12],[14,16,18],[20,22,24]])print(my_array4)my_array4.shape [[ 2 4 6] [ 8 10 12] [14 16 18] [20 22 24]] (4, 3) 3차원 배열 생성123my_array5 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])print(my_array5)my_array5.shape [[[1 2] [3 4]] [[5 6] [7 8]]] (2, 2, 2) Numpy 기본 함수들 arange zeroes, ones reshape sort argsort arangenp.arange(5)를 넣으면 array안에 5개의 숫자가 순서대로 나오는 배열이 자동으로 만들어진다. 12Array = np.arange(5)print(Array) [0 1 2 3 4] np.arange(a, b, c) : a의 숫자부터 b 숫자까지 C씩 띄워서 배열생성 12aArray = np.arange(1, 9, 2)print(aArray) [1 3 5 7] zeroes, oneszeroes와 ones 함수를 살펴 보자각 함수들은 0과 1을 채워 넣어 배열을 생성하는 함수 들 이다. 1234567891011print(&quot;Zeros_Array&quot;)zeros_array = np.zeros((2,3))print(zeros_array)print(&quot;Data Type is:&quot;, zeros_array.dtype)print(&quot;Data Shape is:&quot;, zeros_array.shape)print(&quot;Ones_Array&quot;)ones_array = np.ones((3,4), dtype='int32')print(ones_array)print(&quot;Data Type is:&quot;, ones_array.dtype)print(&quot;Data Shape is:&quot;, ones_array.shape) Zeros_Array [[0. 0. 0.] [0. 0. 0.]] Data Type is: float64 Data Shape is: (2, 3) Ones_Array [[1 1 1 1] [1 1 1 1] [1 1 1 1]] Data Type is: int32 Data Shape is: (3, 4) 8행에 보면 Array를 행성 하면서 dtype을 int32로 지정 해 준 것을 볼 수 있다. Zeros_Array의 경우 채워진 0들이 모두 float type의 실수 이기 때문에 0. 이라고 나타는 것을 볼 수 있지만, Ones_Array의 경우 1 만 나타난 Int 형태의 type인 것을 볼 수 있다. reshapereshape는 행렬의 모양을 바꿔주는 함수이다.행렬의 모양을 바꿀 때에는 약간의 제약이 있는데예를 들어 설명 해 보자면, 3X4 = 12, 6X2 =12로 형태 변환을 할 수 있지만,3X5 = 15이기 때문에 변환이 불가능 하다.이것이 이해가 가지 않는다면 중학교로 돌아 가야 할 지도 모른다. 123456print(ones_array)print(&quot;Data Shape is:&quot;, ones_array.shape)print(&quot;Ones_array의 형태를 reshpe로 바꿔보자 \\n&quot;)after_reshape = ones_array.reshape(6,2)print(after_reshape)print(&quot;Data Shape is:&quot;, after_reshape.shape) [[1 1 1 1] [1 1 1 1] [1 1 1 1]] Data Shape is: (3, 4) Ones_array의 형태를 reshpe로 바꿔보자 [[1 1] [1 1] [1 1] [1 1] [1 1] [1 1]] Data Shape is: (6, 2) 2차원 배열은 3차원으로도 reshape 할 수 있다. 제약 조건은 3 X 4 = 12 였기 때문에 2 X 3 X 2 = 12가 되기 때문에 reshape 가 가능 하다. 123456789101112after_reshape = ones_array.reshape(2,3,2)print(after_reshape)print(&quot;Data Shape is:&quot;, after_reshape.shape, &quot;\\n&quot;)after_reshape2= ones_array.reshape(-1,6)print(&quot;reshape(-1,6)? \\n&quot;)print(after_reshape2)after_reshape3= ones_array.reshape(3,-1)print(&quot;reshape(3, -1)? \\n&quot;)print(after_reshape3)print(&quot;Data Shape is:&quot;, after_reshape3.shape) [[[1 1] [1 1] [1 1]] [[1 1] [1 1] [1 1]]] Data Shape is: (2, 3, 2) reshape(-1,6)? [[1 1 1 1 1 1] [1 1 1 1 1 1]] reshape(3, -1)? [[1 1 1 1] [1 1 1 1] [1 1 1 1]] Data Shape is: (3, 4) 만일 2차 행렬 reshape에서 한개의 변수만 정해 졌다면, 나머지 는 -1을 써주면 자동으로 알맞은 변수를 정해 줍니다. 3차 행렬 역시 남은 1개만 -1을 써서 reshape 함수로 행렬을 변환 할 수 있습니다. 21.11.02(이 아래 부분은 다음에 UPdate하기로 한다. ) short1 argsortNumpy 인덱싱과 슬라이딩Numpy 정렬","link":"/2021/11/01/Numpy/"},{"title":"kaggle :Plotly_Treemap (Q8)","text":"kaggle dictation (01) plotly.graph_objects as go : 를 이용한 Treemap 많은 계층 구조 데이트를 표현할때 적합. Ben Shneiderman에 의해 1990년도부터 출발 Treemap은 크기(count) 순서로 %에따라 공간을 차지하는 사각형으로 표현됨. 계층에서 동일한 수준에 속하는 각 사각형 집합은 데이터 테이블의 표현식 또는 컬럼을 표현. 계층에서 동일한 수준의 개별 사각형은 컬럼의 Index 언제 사용하면 좋을까- 많은 범주간의 부분과 전체를 시각화 하고 싶을때 - 범주 간의 정확한 비교 대신 큰 특징을 나타내고 싶을때 - 데이터가 계층을 이루고 있을때 사용한 Library12345678import pandas as pdimport numpy as npimport seaborn as snsimport plotly.express as pximport plotly.graph_objects as goimport warningswarnings.filterwarnings('ignore') 사실 이 부분에서 seaborn을 사용 했는지 잘 모르겠음. github에서 plotly가 동적 Livrary라 자꾸 오류가남. data importdata 원문data import 방법data는 Kaggle의 the-typical-kaggle-data-scientist-in-2021 data를 이용하였음. data 불러오기/합치기data를 표현 해 주기 위해 컴퓨터가 읽을 수 있는 형태로 가공. 12df = pd.read_csv('../input/kaggle-survey-2021/kaggle_survey_2021_responses.csv')df = df.iloc[1:, :] df : data frame에 file 연동.df.iloc[1:, :] : 1행부터 끝까지 건너뛰기 없이 선택 행번호(row number)로 선택하는 방법 (.iloc) label이나 조건표현으로 선택하는 방법 (.loc) Ref. loc, iloc을 이용한 행 선택 data encoding (Feature Engineering)사실 이 부분이 feature Engineering에 해당하는 부분인지 잘 모르겠다. 이 부분은 data를 computer로 자동화하여 계산, 동적 그래프를 만들기 위한 부분. ###Feature Engineering####data frame 설정 123456789101112recommend_leng = ( df['Q8'] .value_counts() .to_frame() .reset_index() .rename(columns={'index':'Lenguage', 'Q8':'Count'}) .sort_values(by=['Count'], ascending=False) )df['Q8'].head()recommend_leng dataframe[Q8] : data를 가공하여 분석 할 예정 pd.value_counts() Q8의 data counting, 중복된 data 를 counting 하여 수를 나타냄. pd.frame() dataframe으로 표의 형태를 잡아준다. pd.reset_Index() Q8의 Index reset, 원본 data에는 영향을 주지 않으면서 새로운 Index 생성 Reset_parameter/Ko pd.rename() columns에 Index를 붙여 호출 하기 위해 이름을 바꿔줌 index는 Lenguage로, count는 Q8로 pd.sort_values() count 값으로 정렬 by=[‘Count’], ascending = false by에 option 기준, (오름차순 = F )= 내림차순으로 정렬 앞으로 사용 할 색상을 미리 지정 한 눈에 보기 편함. 123456colors = ['#033351',] * 13colors[0] = '#5abbf9'colors[1] = '#066eb0'colors[2] = '#044a77'colors[3] = '#043e64'colors[4] = '#043e64' 아직 잘 모르겠는 부분은 왜 colors = [‘#NNNNNN’, ] 이 부분과 *13 이부분 Treemap 생성123456fig = go.Figure(go.Treemap( labels = recommend_leng['Lenguage'], values = recommend_leng['Count'], parents = ['']*recommend_leng.shape[0], textinfo = &quot;percent root+label+value+text&quot;, )) fig 생성 import plotly.graph_objects as goplotly의 graph_objects 를 이용하여 객체 생성. Treemap의 parameter labels : values 이름 values : 값 parents : ??? textinfo = 표시형식 fig.update_traces(hovertemplate)12fig.update_traces(hovertemplate='&lt;b&gt;Lenguage&lt;/b&gt;: %{label}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;'+ '&lt;b&gt;Count&lt;/b&gt;: %{value}') fig.update_traces() 그래프 위에 캡션 다는 기능 Perform a property update operation on all traces that satisfy the specified selection criteria 지정된 선택 기준을 충족하는 모든 추적에 대해 속성 업데이트 작업 수행 (?? 전혀 모르겠군 !) hoverinfo : 마우스 오버시 나타나는 추적정보 hovertemplate : 커서를 가까이 대면 나오는 창을 렌더링하는데 사용되는 Temp 변수 : %{variable} (변수의 형식을 지정) 숫자 : %{d3-format} price : %{yL$.2f} hovertemplate/en hoverTemp.para/ko fig.update_layout()fig의 layout을 설정. hoverTemp까지 설정된 treemap. fig.update_layout()을 사용하여 layout을 변경 해 보자. 1234567891011121314fig.update_layout(showlegend=False, treemapcolorway = colors, margin=dict(pad=20), paper_bgcolor='#F7F7F7', plot_bgcolor='#F7F7F7', height=600, yaxis={'showticklabels': False}, yaxis_title=None, xaxis_title=None, title_text=&quot;Most Recommended &lt;b&gt;Programming Language&lt;/b&gt;&quot;, title_x=0.5, title_y=0.95, font=dict(family=&quot;Hiragino Kaku Gothic Pro, sans-serif&quot;, size=17, color='#000000'), title_font_size=35) showlegend = False 래전드를 보여줄지 : 안보여줌 treemapcolorway = colors 위에서 정의 해 준 colors가 13개였는데 여기 계층도 13개임 아마도 light 부터 deep으로 색이 정해지는듯. margin=dict(pad=20)-dic에는 여러가지가 올 수 있는데 여기서는 dict(pad)를 사용 padding을 설정, 축과 그래프 사이의 패딩을 px 단위로 설정 Sets the amount of padding (in px) between the plotting area and the axis lines layout-margin paper_bgcolor=’#F7F7F7’ 배경색 설정 plot_bgcolor=’#F7F7F7’ 설정 바꿔 보았으나 안보임 height=600 plot size 설정 yaxis={‘showticklabels’: False} y축의 showticklabels 설정 : 안함 yaxis_title=None, xaxis_title=None y축 제목, x축 제목 설정 : 없음 title_text=”Most Recommended Programming Language“ 제목 달기 &lt;b&gt; code는 bolde tag인듯. title_x=0.5, title_y=0.95, 제목의 위치 (상단 고정) font=dict(family=”Hiragino Kaku Gothic Pro, sans-serif”, size=17, color=’#000000’), title_font_size=35) title의 font 설정 (Default: “”Open Sans”, verdana, arial, sans-serif”) font 설정 family, color, size 설정 가능, title_fond도 함께 설정 가능 해 보임. fig Information 추가fig.add_annotation() _1플롯에 메모를 남길 수 있는것. 코멘트나 copy-Right 같은걸 남기는듯 -[plotly-annotation/ko.] (https://soohee410.github.io/plotly_annotation) 12345678fig.add_annotation(dict(font=dict(size=14), x=0.96, y=-0.14, showarrow=False, text=&quot;@miguelfzzz&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;)) dict = dictionary A list or tuple of dicts of string/value properties where:The ‘type’ property specifies the trace type 여기서 dict는 fig객체 즉 plotly.graph_objects.Figure 에서 상응하는 정보(font, size등) 변수를 가져와 대응 시켜 주는 역할을 한다. plot 아래에 보면 “@miguelfzzz”이라는 글자가 보이는데 이것을 설정 한 것. showarrow=False, 화살표등을 남길 수 있는데 이 Graph에선 false xref=”paper”, yref=”paper” 어느 부분 (plot or paper)에 표시 할 것인지 나머지는 말 안해도 이제는 알 수 있기 때문에 생략. fig.add_annotation() _212345678fig.add_annotation(dict(font=dict(size=12), x=0.01, y=-0.14, showarrow=False, text=&quot;Source: 2021 Kaggle Machine Learning &amp; Data Science Survey&quot;, xanchor='left', xref=&quot;paper&quot;, yref=&quot;paper&quot;)) fig.show() 내보내기1fig.show() fig.show()로 마무리 해 주면 된다. 이건 java의 return과 같은 느낌인듯. Plotly Treemap/en. layout/en.","link":"/2021/11/08/Kgg_plotly_treemap/"},{"title":"Study Pandas","text":"Pandas 판다스란pandas는 데이터를 시각화 하기 좋은 python base의 한 라이브러리이다. python을 이용한 data분석과 같은 작업에서 필수적으로 쓰이고 있다. 아나콘다와 같은 IDE를 이용하여 작업 할 수도 있지만, 기본적으로 Import하여 편하게 사용 할 수 있다. 판다스의 이름은 계량 경제학에서 사용되는 용어인 **’PANel DAta’**의 앞 글자를 따서 지어졌다.판다스는 R에서 사용되던 data.frame 구조를 본뜬 DataFrame이라는 구조를 사용하기 때문에, R의 data.frame에서 사용하던 기능 상당수를 무리없이 사용할 수 있도록 만들었다.더욱이 파이썬이라는 접근성이 좋은 언어 기반으로 동작하기 때문에 데이터 분석을 파이썬으로 입문하는사람들이 필수적으로 사용하는 라이브러리가 되었다.’ 판다스 Import 하기쥬피터 노트로 설치가 가능 하다고 하지만, 구글코랩이나 케글 노트에서는 Import하여 쉽게 사용한다. 12import pandas as pdpd.__version__ pandas는 오픈소스로 누구나 무료로 이용 할 수 있고,Numpy, matplotlib등 다른 라이브러리들과 함께 쓰인다. 일반적으로 pandas는 pd로 import되기 때문에 pd.[function] 으로 써있으면pandas 라이브러리를 이용한다고 생각 하면 된다. Livraly의 경우 version 오류가 많이 있으므로,Import 해 주는 라이브러리는 version을 꼭 확인하여 오류에 대비 하도록 한다. Pandas에는 3가지 자료 구조가 있는데series 와dataFrame,panel 이 그것이다. pandas에대해 더 알아보고 싶다면, 링크를 타고 가보자. ref. 판다스/위키 판다스를 이용에는 유용한 Tutorial들이 있다.아래 있으니 시간이 날 때마다 보면서 Update하자. 영문판이 있지만 지금은 일단 한글 번역한것을 보자화이팅 ! 판다스/doc10 minutes to Pandas/한글","link":"/2021/11/02/Pandas/"},{"title":"python_List","text":"google Colaboratory 를 이용한 실습 Intro_ print와 주석처리 print Out 1print(&quot;Hello, World !!&quot;) Hello, World !! 이제 우리는 모든 것을 나타 낼 수 있습니다. 주석처리 1234567# 한 줄로 주석 처리 하는 방법 &quot;&quot;&quot;여러줄은 이렇게 print(&quot;Hello, World??&quot;)&quot;&quot;&quot;print(&quot;Hello, World!!&quot;) #주석 처리한 부분은 안나오지 Hello, World!! 변수의 종류 int : 정수 float : 실수 bool : 참/거짓 none : null String : 문자 이전에 배웠던 JAVA와는 다르게 변수형을 지정 해 주지 않아도 된다 Type 함수는 그 변수의 type이 어떤 것인지 알려준다. 123456789101112N_int = 1print (type(N_int))#Type 함수 : type 을 print 해 준다 N1_float = 2.0print (type(N1_float))bool_N = Trueprint (type(bool_N))X= Noneprint (type(X)) &lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'NoneType'&gt; 연산 사칙연산 Number type 123456789101112131415161718192021a = 1b = 2c = 3.14d = 1.414print (&quot;정수_int_의 사칙연산 &quot;)print ('a + b = ' , a+b)print('a - b = ', a-b)print('a * b = ', a*b)print('a / b = ', a/b)print('a // b = ', a//b)print('a % b = ', a%b)print('a ** b = ', a**b)print (&quot;실수_float_의 사칙연산 &quot;)print('c + d =', c+d)print('c - d =', c-d)print('c * d =', c*d)print('c / d =', c/d)print('c // d =', c//d)print('c % d =', c%d)print('c ** d =', c**d) 정수_int_의 사칙연산 a + b = 3 a - b = -1 a * b = 2 a / b = 0.5 a // b = 0 a % b = 1 a ** b = 1 실수_float_의 사칙연산 c + d = 4.554 c - d = 1.7260000000000002 c * d = 4.43996 c / d = 2.2206506364922207 c // d = 2.0 c % d = 0.3120000000000003 c ** d = 5.042646477882085 String 연산 1234str1 = &quot;hi&quot;str2 = &quot;bye&quot;print('str1 + str2 = ', str1 + str2 )print ('str 1 * 3 + str * 2 = ', str1 * 3 + str2 * 2 ) str1 + str2 = hibye str 1 * 3 + str * 2 = hihihibyebye indexing1234567891011121314151617181920greeting = &quot;Hi!Hellow? AnNyung!&quot;print(greeting)#greeting, 이하니처럼 인사를 해 봅시다. print(greeting[6:])print(greeting [:6])G = &quot;12345 6789@&quot;print (G[2:])print (G[:3])print (G[1:9])print (G[0:7:3])&quot;&quot;&quot; [a : b : c] a : 시작 index b : 끝 Index c : 띄워서&quot;&quot;&quot; Hi!Hellow? AnNyung! low? AnNyung! Hi!Hel 345 6789@ 123 2345 678 146 ' \\n[a : b : c]\\n a : 시작 index\\n b : 끝 Index\\n c : 띄워서\\n' List List 함수 종류 .append() : 추가 .extend() : 연장 .remove() : 제거 .del() : 제거 .pop() :Index설정 .clear() : 전체 삭제 Internet에 더 많은 함수를 찾을 수 있는 documents 가 있을 것이다.^^ List Function List란, java로 치면 배열 List create 부터 123456789101112131415161718192021222324252627282930313233343536373839404142print(&quot;List 를 생성 해 봅시다.&quot;)A = [] #변수선언으로 빈 리스트 만들기a= list() #List 함수로 만들기 a = ['I', 'Have', ['a', 'DreAm']]print (&quot;a함수에 직접적 Index로 넣어주기&quot;)print (a)print (&quot;a[0]= 'YOU'의 결과 &quot;)a[0]= 'YOU'print (a)#List에 값 추가 해 주기print(A)A.append('U')A.append('song')A.append(['to', 'sing'])print(&quot;A[0:] : A의 모든 원소 추출&quot;)print(A[0:])print(&quot; &quot;)#Extend print(&quot;a : a에 Extend를 이용하여 원소 추가하기&quot;)print(a)a.extend('U')print(a)a.extend(['song', 'to', 'sing'])print(a)#Extend 와 같은 느낌으로 &quot;+=&quot; 연산자를 써 줄수 있다. print(&quot;a : a에 연산자를 이용하여 원소 추가하기&quot;) a += ['Like U']print(a)#Insert는 중간에 인덱스 값을 넣어 주어서 List에 값을 추가 해 줄 수 있다. print(a)print(&quot;a : a에 insert를 이용하여 원하는 Index번호에 원소 추가하기&quot;)a.insert(1,'do not')print(a)del a[1:1]#다음 코드를 위해 a의 Index 1에 넣어준 원소를 제거 했음 List 를 생성 해 봅시다. a함수에 직접적 Index로 넣어주기 ['I', 'Have', ['a', 'DreAm']] a[0]= 'YOU'의 결과 ['YOU', 'Have', ['a', 'DreAm']] [] A[0:] : A의 모든 원소 추출 ['U', 'song', ['to', 'sing']] a : a에 Extend를 이용하여 원소 추가하기 ['YOU', 'Have', ['a', 'DreAm']] ['YOU', 'Have', ['a', 'DreAm'], 'U'] ['YOU', 'Have', ['a', 'DreAm'], 'U', 'song', 'to', 'sing'] a : a에 연산자를 이용하여 원소 추가하기 ['YOU', 'Have', ['a', 'DreAm'], 'U', 'song', 'to', 'sing', 'Like U'] ['YOU', 'Have', ['a', 'DreAm'], 'U', 'song', 'to', 'sing', 'Like U'] a : a에 insert를 이용하여 원하는 Index번호에 원소 추가하기 ['YOU', 'do not', 'Have', ['a', 'DreAm'], 'U', 'song', 'to', 'sing', 'Like U'] 리스트 연산 12C = a+Aprint(&quot;a+A의 연산결과 : &quot;, C) ['U', 'do not', 'song', 'to', 'sing', 'U', 'song', ['to', 'sing']] 리스트에 값 삭제 해 주기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546b=[1, 2, 3, 4, 5, 6 ]B=[7, 8, 9, 10, 11, 12, 13, 1, 4]print(&quot;리스트 값 삭제하기 &quot;)print(b)print(B)print(&quot;b의 1번째 삭제&quot;)#1개씩 삭제 해 주기 del b[1]print(b)print(&quot;B의 1~2 번째 삭제 : [1:2]&quot;)#범위로 삭제 해 주기 del B[1:2]print(B)#중복 값을 삭제 해 주는 functionK=[0, 1, 2, 3, 4, 5, 8, 6, 7, 9, 10, 0, 12]print(&quot;K : &quot;, K)K.remove(0)print(&quot;K.remove(0) : &quot;, K)K.insert(0, 1)print(&quot;K.insert(0,1) : &quot;, K)#pop은 Index를 정해서 특정 문자에 정해 줄 수 있다. S = b.pop()SS= B.pop(1)print(&quot;b.pop() : &quot;)print (S, &quot; : ()안에 아무것도 쓰지 않으면 맨 마지막 &quot;)print(&quot;B.pop(1) : &quot;)print(SS, &quot; : ()안에 숫자를 쓰면 (1) 1번Index 뽑아내기&quot;)#pop과 같은 느낌으로 특정 문자를 뽑아 내기 print(&quot;Index 숫자로 pop과 같은 기능을 실행 할 수 있다. &quot;)print (a[0:])print (a[2][1])print (a[2][1][3])#List 전체 삭제 리스트 값 삭제하기 [1, 2, 3, 4, 5, 6] [7, 8, 9, 10, 11, 12, 13, 1, 4] b의 1번째 삭제 [1, 3, 4, 5, 6] B의 1~2 번째 삭제 : [1:2] [7, 9, 10, 11, 12, 13, 1, 4] K : [0, 1, 2, 3, 4, 5, 8, 6, 7, 9, 10, 0, 12] K.remove(0) : [1, 2, 3, 4, 5, 8, 6, 7, 9, 10, 0, 12] K.insert(0,1) : [1, 1, 2, 3, 4, 5, 8, 6, 7, 9, 10, 0, 12] b.pop() : 6 : ()안에 아무것도 쓰지 않으면 맨 마지막 B.pop(1) : 9 : ()안에 숫자를 쓰면 (1) 1번Index 뽑아내기 Index 숫자로 pop과 같은 기능을 실행 할 수 있다. ['hi', 'do not', 'Have', ['a', 'DreAm'], 'U', 'song', 'to', 'sing', 'd', 'i', 'd', ' ', 'n', 'o', 't'] a --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-112-d37801788a81&gt; in &lt;module&gt;() 40 print (a[0:]) 41 print (a[2][1]) ---&gt; 42 print (a[2][1][3]) 43 44 #List 전체 삭제 IndexError: string index out of range List 값을 덮어 쓰는 기능 12345678print (&quot;A[] = &quot;, A) print (&quot;A[1:2]= ['i', 'do', 'NOT', 'know']의 결과 &quot;)A[1:2]= ['i', 'do', 'NOT', 'know']print (A) # A[]에 1번 Index에 범위보다 큰 수가 엎어 씌어 진 것을 볼 수 있다. del A [1:4]print(&quot;del A [1:4] : &quot;, A) A[] = ['U', 'i', 'do', 'NOT', 'know', 'do', 'NOT', 'know', 'do', 'NOT', 'know', ['to', 'sing']] A[1:2]= ['i', 'do', 'NOT', 'know']의 결과 ['U', 'i', 'do', 'NOT', 'know', 'do', 'NOT', 'know', 'do', 'NOT', 'know', 'do', 'NOT', 'know', ['to', 'sing']] del A [1:4] : ['U', 'know', 'do', 'NOT', 'know', 'do', 'NOT', 'know', 'do', 'NOT', 'know', ['to', 'sing']] Ref.https://dojang.io/course/view.php?id=7 보고 공부 할 수 있어요","link":"/2021/11/05/Python_List/"},{"title":"python_Tuple","text":"TupleTuple은 List에비해 메모리 사용 효율이 좋지만, 정보 수정이 어렵다. splicing 기능, +, * 의 연산은 가능하다. 1 Dictionary1 If 조건문1 for 반복문1","link":"/2021/11/05/Python_tuple/"},{"title":"Kaggle Note 사용하기","text":"google colab에서 실행되지 않는google colab에서 version 오류로 실행 되지 않는 것들이 있다고 한다.따라서 이때 Kaggle data를 이용 할 예정이면 Kaggle Note를 사용해 보는 것은 어떨까? ‘+ Create’ 표시를 누른다. - New NoteBook - New dataSet 탭이 나온다. New NoteBook을 선택하여 이용해 보자. 아래와 같은 코드가 나오게 된다. 123456789101112131415161718192021# This Python 3 environment comes with many helpful analytics libraries installed# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python# For example, here's several helpful packages to loadimport numpy as np # linear algebraimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)# Input data files are available in the read-only &quot;../input/&quot; directory# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directoryimport osfor dirname, _, filenames in os.walk('/kaggle/input'): for filename in filenames: print(os.path.join(dirname, filename))# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using &quot;Save &amp; Run All&quot; # You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session 이것을 유지 한채 아래에 code 연습을 하면 되는 것 같다. 21.11.05_","link":"/2021/11/05/Using_Kaggle_Note/"},{"title":"visualization by python","text":"Visualization _python으로[1103 학습]시각화 연습 및 작성 코드 깃헙 블로그 및 깃헙에 올리기, 개인별로 공유 시각화 올릴 때, 전체 코드 올리지 마시고,나눠서 올리세요. 설명 글 추가하시고여~ (예시 하단) 산점도: 산점도란 무엇인가? 언제 쓰는가? 코드 작성 및 간단 설명박스플롯: 박스플롯이란 무엇인가? 언제 쓰는가? 코드 작성 및 간단 설명 오후 1시까지 1차로 한번 올려서 개인별로 공유해주세요. 홧팅요 Intropython에서 visualiztion 하기 위해서는 많은 방법이 있다. data Analist들은 시각화를 위해 많은 tool을 사용 하는데 우리는 Seaborn과 Matplotlib을 이용하여 시각화를 할 예정이다. 코드 기반(python)의 data visualiztion의 장점 여러 그래프 동시 작성 가능 기존의 코드 재활용성 데이터 그기의 제한이 없음 (RAM등의 제약조건 없을때) Matplotlib 는 이미지 데이터와 정형 데이터(정적 그래프)를 시각화 할 수 있는데 나와 같은 비전공자들에게 시각화 문법이 조금 어렵다고 한다. 하지만 pandas data frame에서 쉽게 시각화 구현 하며, 통계(회귀선) 그래프 등을 쉽게 구현 할 수 있기 때문에 이를 배워야 한다. seaborn의 경우 그래프가 예쁘게 나오지 않지만 비교적 간단한 코드로 시각화를 할 수 있다. 하지만, 세부 옵션을 수정 하고 싶다면 Matplotlib를 알아야 한다. 이는 내부 원리를 파악 할 수 없기 때문에 내가 감당하기 힘들다. 때문에 지금 단계에서는 Matplotlib과 seaborn의 장점을 적절하게 섞어서 시각화를 진행 해 보자. 아래와 같은 Tutorial을 진행 하면 세부 옵션을 조정 하기 쉽다고 한다.https://matplotlib.org/stable/tutorials/index.html matplotlibmatplotlib를 이용하여 visualiztion을 해 보자. 제일 먼저 해 주어야 할 일은 Import하여 matplotlib를 불러오고 이를 plt등의 객체에 저장 해 주는 것이다. 123456789import matplotlib.pyplot as pltdates = [ '2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08', '2021-01-09', '2021-01-10']min_temperature = [20.7, 17.9, 18.8, 14.6, 15.8, 15.8, 15.8, 17.4, 21.8, 20.0]max_temperature = [34.7, 28.9, 31.8, 25.6, 28.8, 21.8, 22.8, 28.4, 30.8, 32.0] 위의 data는 강사님의 data를 가져 온 것이다. data를 시각화 자료로 만들어 보자, 12345fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(10,6))axes.plot(dates, min_temperature, label = 'Min Temperature')axes.plot(dates, max_temperature, label = 'Max Temperature')axes.legend()plt.show() 위의 표는 legend가 있고, 날짜별로 Min Temp와 Max Temp가 있는 그래프 이다. 먼저 fig, ax = plt.subplots()를 이용하여 표를 생성 한다. 이때 figure에대한 정보를 함께 생성 할 수 있는데, (nrows=1, ncols=1, figsize=(10,6)) 가 의미하는 것은 (행의 갯수 =1, 열의 갯수=1, fig size는 10X6)이다. ax를 통하여 plot 형태의 그래프를 그리는데, (x축, y축 , label = “[name]”)의 형태로 plot을 추가 해 준다.이때 Legend 를 생성 하고 싶다면, ax.legend()함수로 추가 해 줄 수 있다. 마지막으로 plt.show() 를 사용하여 마무리 해 준다. 물론 마지막 코드를 넣지 않아도 보여 주지만, 넣어주는 것이 인지상정이라고 한다. 123print(fig)print(axes) Figure(720x432) AxesSubplot(0.125,0.125;0.775x0.755) 위의 표인 fig의 정보를 알 수 있게 print 함수로 뽑아 봤는데 이건 무슨 말 인지 잘 모르겠다. matplotlib로 선 그래프 그리기아직 data를 어디에서 받을 수 있는지 잘 모르기 때문에 강사님이 다운받은 표를 그대로 가져와 보자 참조: https://pypi.org/project/fix-yahoo-finance/ 1!pip install yfinance --upgrade --no-cache-dir Collecting yfinance Downloading yfinance-0.1.64.tar.gz (26 kB) Requirement already satisfied: pandas&gt;=0.24 in /usr/local/lib/python3.7/dist-packages (from yfinance) (1.1.5) Requirement already satisfied: numpy&gt;=1.15 in /usr/local/lib/python3.7/dist-packages (from yfinance) (1.19.5) Requirement already satisfied: requests&gt;=2.20 in /usr/local/lib/python3.7/dist-packages (from yfinance) (2.23.0) Requirement already satisfied: multitasking&gt;=0.0.7 in /usr/local/lib/python3.7/dist-packages (from yfinance) (0.0.9) Collecting lxml&gt;=4.5.1 Downloading lxml-4.6.4-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.manylinux_2_24_x86_64.whl (6.3 MB) \u001b[K |████████████████████████████████| 6.3 MB 7.7 MB/s \u001b[?25hRequirement already satisfied: python-dateutil&gt;=2.7.3 in /usr/local/lib/python3.7/dist-packages (from pandas&gt;=0.24-&gt;yfinance) (2.8.2) Requirement already satisfied: pytz&gt;=2017.2 in /usr/local/lib/python3.7/dist-packages (from pandas&gt;=0.24-&gt;yfinance) (2018.9) Requirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.7/dist-packages (from python-dateutil&gt;=2.7.3-&gt;pandas&gt;=0.24-&gt;yfinance) (1.15.0) Requirement already satisfied: urllib3!=1.25.0,!=1.25.1,&lt;1.26,&gt;=1.21.1 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (1.24.3) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (3.0.4) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (2.10) Requirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (2021.5.30) Building wheels for collected packages: yfinance Building wheel for yfinance (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for yfinance: filename=yfinance-0.1.64-py2.py3-none-any.whl size=24109 sha256=25a6e16cba240e66cb4999d0947a231b790b2b96766767434407e09149ec9302 Stored in directory: /tmp/pip-ephem-wheel-cache-a8wml444/wheels/86/fe/9b/a4d3d78796b699e37065e5b6c27b75cff448ddb8b24943c288 Successfully built yfinance Installing collected packages: lxml, yfinance Attempting uninstall: lxml Found existing installation: lxml 4.2.6 Uninstalling lxml-4.2.6: Successfully uninstalled lxml-4.2.6 Successfully installed lxml-4.6.4 yfinance-0.1.64 123456import yfinance as yfdata= yf.download('AAPL', '2019-08-01', '2021-08-01')data.info()print(yf) [*********************100%***********************] 1 of 1 completed &lt;class 'pandas.core.frame.DataFrame'&gt; DatetimeIndex: 504 entries, 2019-08-01 to 2021-07-30 Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Open 504 non-null float64 1 High 504 non-null float64 2 Low 504 non-null float64 3 Close 504 non-null float64 4 Adj Close 504 non-null float64 5 Volume 504 non-null int64 dtypes: float64(5), int64(1) memory usage: 27.6 KB &lt;module 'yfinance' from '/usr/local/lib/python3.7/dist-packages/yfinance/__init__.py'&gt; info() 함수를 통해 column정보와 data의 갯수, data의 type까지 알 수 있다.date time index에 구간이 내가 정한데로 나와 있는 것도 볼 수 있다. 12ts = data['Open']print(ts.head()) Date 2019-08-01 53.474998 2019-08-02 51.382500 2019-08-05 49.497501 2019-08-06 49.077499 2019-08-07 48.852501 Name: Open, dtype: float64 ts 객체에 Open data를 담고 .head() 함수로 상위 5개의 항목을 가져와 본다. 혹시,Pandas 에대하여 더 정리된 것을 알고 싶다면, 링크를 통해 확인 할 수 있다. Pyplot API아래의 예는 Pyplot API 방법을 이용하여, 한개씩 data를 넣어 준 형태 이다. 이는 객체지향으로 만들었다고 하기 어렵지만, 가능은 하다. 12345678910111213# import fix_yahoo_finance as yfimport yfinance as yfimport matplotlib.pyplot as pltdata = yf.download('AAPL', '2019-08-01', '2020-08-01')ts = data['Open']plt.figure(figsize=(10,6))plt.plot(ts)plt.legend(labels=['Price'], loc='best')plt.title('Stock Market fluctuation of AAPL') plt.xlabel('Date') plt.ylabel('Stock Market Open Price') plt.show() [*********************100%***********************] 1 of 1 completed Pyplot API 객체지향12345from matplotlib.backends.backend_aggimport FigureCanvasAgg as FigureCanvasfrom matplotlib.figure import Figureimport matplotlib.pyplot as plt 객체지향을 위해 import를 해 준다. 1234567891011fig = Figure()import numpy as npnp.random.seed(6)x = np.random.randn(20000)ax = fig.add_subplot(111)ax.hist(x, 100)ax.set_title('Artist Layer Histogram')# fig.savefig('Matplotlib_histogram.png')plt.show()","link":"/2021/11/03/Visualiztion__python/"},{"title":"BearSoup_Review","text":"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 논문 리뷰======= c5589a672e850f5edca309f81ca50915cbf17ada","link":"/2021/11/03/bearSoup_Review/"},{"title":"Making Category","text":"--- title: &quot;Making Category&quot; excerpt :&quot;Credit card&quot; classes: wide categories: -init tags: -python -title -coding last_modified_at: 2021-11-03 --- color 바꾸고 싶은에 안되네 https://www.color-hex.com/color/f4dcdc","link":"/2021/11/04/categories/"},{"title":"Pandas_DataFrame","text":"#pandas에서 dataFrame 자료구조. dataFrame은 표와 같은 스프레드 시트 형식의 자료 구조이다. 2차원 배열 또는 리스트, data table 전체를 포함하는 object라고 볼수 있음. 여러개의 column이 있고, 각 컬럼은 숫자, 문자열, boolean type을 담을 수 있다. dataFrame은 Rew, column에대한 Index 이렇게 2가지 변수를 담고 있는데 matrix라고 할 수 있다. pd.dataframe()1234567import pandas as pdvalues = [['rose', 'tulip', 'Liry'], [4, 5, 6], ['red', 'blue', 'green']]index = ['flower', 'Number', 'color']columns = [1, 2, 3]df = pd.DataFrame(values, index=index, columns=columns)print(df) df 는 data frame의 준말. 1 2 3 flower rose tulip Liry Number 4 5 6 color red blue green Index와 column 의 dtype은 object이다. 데이터프레임은 리스트(List), 시리즈(Series), 딕셔너리(dict), Numpy의 ndarrays,또 다른 데이터프레임으로 생성할 수 있습니다. Ref.DataFrame","link":"/2021/11/06/dataFrame(pandas)/"},{"title":"to use gitHub in Multi place","text":"깃허브 노트북과 데스크탑 두군데서깃허브를 동시에 사용하고 싶은 분들은아래 코드 확인해서 해보세요. 이 때, 깃헙 blog 저장소 삭제할 필요가 없어요~ 123456789101112$ hexo init myblog # 여기는 각자 소스 레포 확인$ cd myblog$ git init $ git remote add origin https://github.com/rain0430/myblog.git # 각자 소스 레포 주소$ git pull --set-upstream origin main # 에러 발생$ git clean -d -f$ git pull --set-upstream origin main # 에러 발생 안함 / 소스 확인$ npm install $ hexo clean$ hexo generate$ hexo server 저장 해 놓고 나중에 해 봐야지 .","link":"/2021/11/02/gitHub_multi/"},{"title":"Hello World","text":"Welcome to Hexo!This is your very first post. Check documentationfor more info. If you get any problems when using Hexo,you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/10/01/hello-world/"},{"title":"kaggle study","text":"Sumarry Demographics &amp; Geographics (Q1) Age-bar (Q2) Gender-pie (Q3)countries-scatter+line Education &amp; Occupation (Q4) Age-bar_h (Q5) Role-bar_h (Q20) Industry-bar_h knowledge &amp; skills (Q6) Experience : 52% 넘는 응답이 3년이상 코딩과 프로그래밍을 했다. -bar vertical (위) (Q17) Algorithms : Linear or Logistic Regression 55% 과 Decision tree or Random Forests, respectively 66% 사용. - bar horizon (옆) (Q7) Languages : python 84%, SQL 41% 사용 -bar horizon (Q8) Recommend_Leng: programming에 추천하는 언어는 81%가 python -Treemap (Q9) F_EG /w Q7 가장 많이 쓰는 IDE : jupyter Notebook26.2%, VSCODE 13.92% - bar horizon Platforms &amp; Media4. Platforms &amp; Media (Q11) Platform: 많이 쓰는 컴퓨터 플랫폼은 랩탑이 66% -Scatter + line (Q27_A)cloud_platform: 아마존 14%, 구글클라우드 12%, 마쏘 아줠 9% - bar horizon (Q40) courses: DS들이 많이 쓰는 course 플랫폼 Coursera 20, Kaggle 18%-Treemap (Q42) media : DS topic report를 위해 많이 쓰는 media는 kaggle 44%, youTube 40%, blog 31% -scatter + line Takeaways : typical Kaggle DS in 2021 :HTML picture n line n text 123456789101112131415161718# This Python 3 environment, PKG Loadimport numpy as np # linear algebraimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)# Input data files : &quot;../input/&quot; # Running : Shift+Enterimport osfor dirname, _, filenames in os.walk('/kaggle/input'): for filename in filenames: print(os.path.join(dirname, filename))# ~ 20GB ,/kaggle/temp/ /kaggle/input/kaggle-survey-2021/kaggle_survey_2021_responses.csv /kaggle/input/kaggle-survey-2021/supplementary_data/kaggle_survey_2021_methodology.pdf /kaggle/input/kaggle-survey-2021/supplementary_data/kaggle_survey_2021_answer_choices.pdf The Typical Kaggle Data Scientist in 2021 Remade By @YoonHwa-P HTML code는 Markdown 형식으로 넣을 수 있게 해 준다. scr : 구글 팟케스트에서 바로 연결하여 사용. 1234567891011import pandas as pdimport numpy as npimport seaborn as snsimport plotly.express as pximport plotly.graph_objects as goimport warningswarnings.filterwarnings('ignore') 시각화, 계산을 위해 Pandas, Numpy, seaborn을 이용 할 것이고, 동적보드를 만들기 위해 plotly를 이용 하였다. plotly 중에서 Express와 Graph_objects를 가져와서 사용 할 예정인듯. plotly-express The Plotly Express API in general offers the following features: Every PX function returns a** plotly.graph_objects.Figure object**, so you can edit it using all the same methods like update_layout and add_trace. input으로 Express를 사용 한다면 Graph_objects가 동적 plotly 를 만드는 것 같다. : update 하거나 trace를 가능 하게 하는듯. 실제 필사할 data에서는 어떤 data가 있는지 확인 해 보지 않았지만,나는 배우는 입장이니 어떤 data가 있는지, 어떤 head가 있는지 확인 해 보도록 한다. 맨 위에 가보면 Note가 생성 될때 /kaggle/input/kaggle-survey-2021/kaggle_survey_2021_responses.csv /kaggle/input/kaggle-survey-2021/supplementary_data/kaggle_survey_2021_methodology.pdf /kaggle/input/kaggle-survey-2021/supplementary_data/kaggle_survey_2021_answer_choices.pdf 위와같은 file dir을 알려준다. 이제, pandas로 이 files를 로딩 시켜 주면된다. Ref. Kaggle활용.국문 12345678df = pd.read_csv(&quot;../input/kaggle-survey-2021/kaggle_survey_2021_responses.csv&quot;)df = df.iloc[1:, :] #이건 왜 선택 해 놓은 것일까요?df.head()df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 25973 entries, 1 to 25973 Columns: 369 entries, Time from Start to Finish (seconds) to Q38_B_OTHER dtypes: object(369) memory usage: 73.1+ MB df에 pd.read_csv로 csv file을 읽어 옵니다. 역시 pd인 df객체에 iloc을 이용하여 [ 1행부터 : , : ] iloc를 선택 해 놓았다. 행번호(row number)로 선택하는 방법 (.iloc) label이나 조건표현으로 선택하는 방법 (.loc) Ref. loc를 이용한 행 선택 0. Introduction This notebook will explore the fascinating results obtained from the survey conducted by Kaggle in September 2021. Over 25,000 data scientists and ML engineers participated, providing information on their backgrounds and experience in their occupations. To increase readability, this report is divided into four sections: Demographics & Geographics Education & Occupation Knowledge & Skills Platforms & Media Introduction이 노트북은 25000 data scientist들과 ML Engineer들의 kaggle에서 경험 한것을 조사한 data를 매력적인 결과로 탐험 하게 될 것이다.(대충) ; Introduction 에서 이 notebook의 성격, data의 간간한 정보, 목차 등을 설명. 모든 글은 Markdown을 이용한 css 로 작성 된 것 같다. 혹시,css에 대하여 더 알아보고 싶으면, 이 문서를 참조 하자.","link":"/2021/11/07/kaggle_CC/"},{"title":"Method Making New Repository","text":"Hello World I’m in the Mars Github에서###새로운 저장소 만들기 git hub 로그인 후 새로운 저장소를 만들어 보도록 합시다. new 를 누르면 새로운 repository를 생성하기 위한 정보를 입렬 할 수있다. Repository name 입력 후 Public(전체 공개)으로 할 것인지, Private(비공개)로 할 것인지 선택한다. 마지막으로 create repository를 누르면 생성됨. 생성된 repository에 README.md file을 생성해 봅시다. git bash를 열어봅시다. (원하는 경로에서) git bash 에서 github에서 만든 file을 내려받아 봅니다.1$ git clone + 나의 경로 혹시 나의 경로를 어디서 찾는지 잘 모르는 나를 위해 남긴다. git bash네… bush인줄알았는데… 원하는 경로에 file이 생긴 것을 볼 수 있다. 이제 README.md file 을 만들어 보자. 위의 My path image를 보면 아랫쪽에 코드가 나와있는 것을 볼 수 있다. New file을 파이참으로 열어준 후 아래 코드를 한줄씩 입력 하면 된다. (위 사진에 나와 있는 코드!! )1234567echo &quot;# New&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M maingit remote add origin https://github.com/ 이 부분이 사람마다 다르니 웹페이지 보고 하기!git push -u origin main 이제 저장소와 Desktop file이 페어링 되었다. 앞으로는 file Update후 git 명령어로 올리면 된다. 예를 들자면, folder에 file을 넣고, pycham으로 foler를 열어서 다음과 같은 명령어를 넣으면 된다. 123git add . -- 모든 file을 업로드 하기 위해 저장git commit -m &quot;history Log로 확인 할수 있는 message&quot; -- 확인git push -- 최종적으로 file을 git hub에 올림 이제 전세계 어디에 있던 대용량 파일 저장소를 직접 손에 들고 다닐 일이 없어진거다. (물론 인터넷이 잘 된다는 가정 하에서….)하지만, 나는 오늘도 노파심에 외장하드를 들고 나왔다 하하 앞으로 github에 다 정리해서 넣고 외장하드 안가지고 다녀야지 ^^ 화이팅 !!","link":"/2021/10/28/make_NewRepository/"},{"title":"machine Learning_basic","text":"machine learningDecision tree learing Decision tree 란 관측값과 목표값을 연결 시켜주는 예측 모델 통계학과 데이터 마이닝, 기계학습에서 예측모델링으로 사용하는 방법 데이터 기능에서 유추된 결정규칙을 학습하여 대상 변수값을 예측 하는 모델을 만들기 위해 사용 ####종류 분류 트리 변수가 유한한 수의 값을 가지는 것, 클래스 출력 Leaf node는 클래스 라벨을 나타내고 가지는 클래스 라벨과 관련있는 특징들의 논리 곱을 나타낸다. 회귀트리 목표변수가 연속하는 값(일반적으로 실수 )을 가지는 트리 특정 의미를 가지는 실수값을 출력 의사결정 분석에서 결정트리는 시각적으로 명시적인 방법으로 과정을 보여준다. 결정트리의 학습 결정 트리의 학습 : 자료 집합을 적절한 분할기준 또는 분할 테스트에 따라 부분집합들로 나누는 과정 하향식 결정 트리 귀납법 (TDIDT_top-down induction of decision trees) 순환분할 방식으로 나눠진 자료의 부분집합에 재귀적으로 반복됨. 분할로 인해 더이상 새로운 예측값이 추가 되지 않거나 부분집합의 노드가 목표변수와 같은 값을 지닐대 까지 계속됨. 데이터 마이닝에서 결정트리 수학 적으로 표현됨 예를 들어 아래와 같은 데이터 마이닝에서의 결정 트리가 있다고 가정 해 보자. ( f{x},Y ) = (x_1, x_2, x_3, ..., x_k, Y) 종속 변수 Y는 분류를 통해 학습하고자 하는 목표 변수이며, 벡터 x는 { x_{1}, x_{2}, x_{3} } x_1, x_2, x_3 등의 입력 변수로 구성된다. 장점1. 이해하기 쉬우며 시각화 가능 2. data 준비가 거의 필요하지 않음 3. 수치형, 범주형 data를 모두 처리 가능 4. multi-output problems를 다룰 수 있다. 5. a white box model을 사용 할 수 있다. (bool 가능) 6. 통계 검정을 사용하여 모형을 검증하기 때문에 모델의 신뢰성을 설명할 수 있다. 7. 생성된 데이터가 실제 모형에 의해 가정이 다소 위반되더라도 잘 수행된다. 단점 data 일반화가 잘 되지 못하면 복잡한 트리가 만들어짐 (과적합) - 가지치기, 리프노드에 필요한 샘플 최소화, 트리 최대깊이 설정 으로 해결 가능 variation이 작은 경우 의사결정트리가 불안정 할 수 있다. 앙상블(ensemble) 내에서 의사결정 트리 사용으로 해결 가능. 실용적인 의사 결정 트리 학습 알고리즘은 각 노드에서 국소적으로 최적의 의사결정이 이루어지는 그리디 알고리즘과 같은 경험적 알고리즘을 기반으로 한다. 이러한 알고리즘은 전역 최적 의사 결정 트리를 반환한다고 보장할 수 없다. 이는 특징과 샘플이 교체와 함께 무작위로 샘플링되는 앙상블 학습기에서 여러 트리를 훈련시킴으로써 완화될 수 있다. 의사 결정 트리의 예측은 근사치이기 때문에 좋은 추정은 아닐 수 있다. 의사결정 트리의 최적화의 문제는 NP-complete로 잘 알려진 문제이다.잘 모르겠다. NP-complete XOR, parity or multiplexer problems와 같이 배우기 쉽지 않은 컨셉들 때문에 표현하기 쉽지않다. 학습자가 편향된 트리르르 만들 수 있으므로, 데이터 세트의 균형을 맞춰줘야 한다. 이어지는 posting classification Regression Ref. 결정트리학습법/wiki 결정트리 국문 Decusuib Trees 1.10.1 1.10.2","link":"/2021/11/04/machineLearning_basic/"},{"title":"Making Blog method","text":"Hello World I’m in the Mars Hi my name is YoonHwa Park ! just call me Yoon ^^. Nice to meet you.Today’s Topic is Making Blog !!! it is not easy to make. (ㅜ_ㅜ) but We Can DO IT ^0^!! If you try to do….(…may be…)Let’s Start!! ###깃허브 블로그 만드는 방법####들어가기 전에! Install Applications gitHub : https://github.com/ pycham : https://www.jetbrains.com/pycharm/ nodejs : https://nodejs.org/en/ ※ 주의 : 설치 중에 SYSTEM PATH 관련 텝이 나오면 Check 하고 넘어가기 회원가입 github : mail 로 회원가입 하기. 나머지 회원가입 권유는 무시해도됨. (하고 싶으면 하시오.) 1$ hexo new &quot;My New Post&quot; Ref.this file is written by MARKDOWN마크다운 기초 확인 하고 작성https://gist.github.com/ihoneymon/652be052a0727ad59601","link":"/2021/10/28/make_blog/"},{"title":"Deploy gitHub blog by hexo","text":"##github blog를 Hexo를 이용하여 deploy 해 보자. Ref. https://dschloe.github.io/settings/hexo_blog/ ###Hexo를 이용하여 블로그를 만들어 보자 Node js를 download 해 준다. Node js 설치 GitBash 에서 node의 version을 확인 1$ node -v Hexo를 설치 해 준다. Hexo의 경우 npm을 이용하여 설치 한다. 1$ npm install -g hexo-cli git bash를 적당한 경로에서 들어간다.makeBlog folder를 만들어준다. 12345$ mkdir makeBlog$ cd makeBlog$ hexo init myblog hexo init 을 myblog에서 해 준다.hexo server와 deployer를 설치 해 준다. 이를 설치 하지 않으면 에러가 날 수 있다. 1234$ cd myblog$ npm install$ npm install hexo-server --save$ npm install hexo-deployer-git --save","link":"/2021/11/04/nodjs/"},{"title":"Pandas_panel","text":"#pandas에서 panel 자료구조.","link":"/2021/11/06/panel(pandas)/"},{"title":"Pandas_Series","text":"#Pandas에서 series 자료구조 series는 1차원 배열같은 자료 구조를 말한다. 아래 code는 python pandas의 parameter 값이다. 123def __init__(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False) series의 parameter는 data, index, dtype, name, copy, fastpath로 나뉘어져 있는데name의 경우는 이름 인 것 같고 기본적으로 Index와 value라는 parameter를 많이 이용 하는 듯 하다. Index : 배열의 이름 value : 값 python의 dictionalry와 거의 유사 한 것 같다. (다음에 찾아보자 오늘은 벅참.) series의 dtype에는 str, numpy.dtype, or ExtensionDtype, optional Data type 을담을 수 있는데 이는 자동으로 값이 입력 되는 것같다. series 객체를 생성 할 때 value와 Index를 직접 지정 해 줄 수 있다. 1234import pandas as pdsr = pd.Series([24000, 20000, 1000, 5000], index=[&quot;피자&quot;, &quot;치킨&quot;, &quot;콜라&quot;, &quot;생맥&quot;])print(sr) 구글 코랩에서 작업 하고 있는데,아래에 보면 series 객체의 parameter에대한 팝업이 나와 공부 하기 참 편하게 해 준다. def init(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)One-dimensional ndarray with axis labels (including time series). Labels need not be unique but must be a hashable type. The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the index. Statistical methods from ndarray have been overridden to automatically exclude missing data(currently represented as NaN).Operations between Series (+, -, /, *, **) align values based on their associated index values– they need not be the same length. The result index will be the sorted union of the two indexes. Parameters data : array-like, Iterable, dict, or scalar value Contains data stored in Series. index : array-like or Index (1d) Values must be hashable and have the same length as data. Non-unique index values are allowed. Will default to RangeIndex (0, 1, 2, …, n)if not provided. If both a dict and index sequence are used, the index willoverride the keys found in the dict. dtype : str, numpy.dtype, or ExtensionDtype, optional Data type for the output Series. If not specified, this will be inferred from data. See the user guide &lt;basics.dtypes&gt; for more usages. name : str, optional The name to give to the Series. copy : bool, default False Copy input data. series pandas","link":"/2021/11/06/series(pandas)/"},{"title":"Lecture_python_basic","text":"Hello World12print(&quot;Hello, world!&quot;)print(&quot;hi ^0^&quot;) Hello, world! 주석처리12345# 한 줄 주석 처리&quot;&quot;&quot;여러 줄 주석 예제 동일한 따옴표(큰따옴표 혹은 작은 따옴표) 세 개와 세 개 사이에는어떠한 내용, 몇 줄이 들어가더라도 모두 주석으로 처리된다.&quot;&quot;&quot;print(&quot;Hello, world!&quot;) Hello, world! 변수의 종류12num_int = 1print(type(num_int)) &lt;class 'int'&gt; 12num_float = 0.2print(type(num_float)) &lt;class 'float'&gt; 12bool_true = Trueprint(type(bool_true)) &lt;class 'bool'&gt; 12none_x = Noneprint(type(none_x)) &lt;class 'NoneType'&gt; 사칙 연산123456789a = 3b = 2print('a + b = ', a+b)print('a - b = ', a-b)print('a * b = ', a*b)print('a / b = ', a/b)print('a // b = ', a//b)print('a % b = ', a%b)print('a ** b = ', a**b) a + b = 5 a - b = 1 a * b = 6 a / b = 1.5 a // b = 1 a % b = 1 a ** b = 9 123456789c = 3.0d = 2.0print('c + d =', c+d)print('c - d =', c-d)print('c * d =', c*d)print('c / d =', c/d)print('c // d =', c//d)print('c % d =', c%d)print('c ** d =', c**d) c + d = 5.0 c - d = 1.0 c * d = 6.0 c / d = 1.5 c // d = 1.0 c % d = 1.0 c ** d = 9.0 논리형 연산자1234print(True and True)print(True and False)print(False and True)print(False and False) True False False False 1234print(True or True)print(True or False)print(False or True)print(False or False) True True True False 비교 연산자123456print(4 &gt; 3)print(4 &lt; 3)print(4 &gt;= 3)print(4 &lt;= 3)print(4 &gt; 4)print(4 &gt;= 4) True False True False False True 논리형 &amp; 비교 연산자 응용123456#input(&quot;숫자를 입력하세요&quot;)_연습하기data = input (&quot;숫자를 입력하세요.&quot;)data2 =int(data)print(type(data2))# class 가 달라진다. data = string , data 2 = int -&gt; 형변환 12345678num1 = int(input(&quot;첫번째 숫자를 입력하세요: &quot;))num2 = int(input(&quot;두번째 숫자를 입력하세요: &quot;))num3 = int(input(&quot;세번째 숫자를 입력하세요: &quot;))num4 = int(input(&quot;네번째 숫자를 입력하세요: &quot;))var1 = num1 &gt;= num2var2 = num3 &lt; num4print(var1 and var2) 첫번째 숫자를 입력하세요: 10 두번째 숫자를 입력하세요: 20 세번째 숫자를 입력하세요: 30 네번째 숫자를 입력하세요: 11 False String12print(&quot;'Hello, world!'&quot;)print('&quot;Hello, world!&quot;') 'Hello, world!' &quot;Hello, world!&quot; String Operators123456str1 = &quot;Hello &quot;str2 = &quot;World &quot;print('str1 + str2 = ', str1 + str2)greet = str1 + str2print('greet * 3 = ', greet * 3) str1 + str2 = Hello World greet * 3 = Hello World Hello World Hello World Indexing12greeting = &quot;Hello Kaggle&quot;print(greeting[6]) K Slicing123456greeting = &quot;Hello Kaggle&quot;print(greeting[:])print(greeting[6:])print(greeting[:6])print(greeting[3:8])print(greeting[0:9:2]) Hello Kaggle Kaggle Hello lo Ka HloKg 1greeting[13] 리스트1234567891011a = [] # 빈 리스트a_func = list() #list()함수로도 빈 리스트를 만들 수 있다.b = [1] # 숫자도 요소가 될 수 있다.c = ['apple'] # 문자열도 요소가 될 수 있다d = [1, 2, ['apple']] # 리스트 안에 리스트를 요소로 넣을 수 있다.print(a)print(a_func)print(b)print(c)print(d) [] [] [1] ['apple'] [1, 2, ['apple']] 123456a = [1, 2, 3]# index [[0], [1], [2]]print(a[0]) # 첫번째 요소print(a[1]) # 두번째 요소print(a[2]) # 세번째 요소print(a[-1]) 1 2 3 3 1234567a = [['apple','banana','cherry'], 1]print(a[0]) # 리스트 내의 리스트print(a[0][0]) # 리스트 내의 리스트의 첫번째 문자열print(a[0][0][3]) # 리스트 내의 리스트의 첫번째 문자열 'apple' 중 첫번째 인덱스print(a[0][1]) # 리스트 내의 리스트의 두번째 문자열print (a[0][2]) ['apple', 'banana', 'cherry'] apple l banana cherry 12345678910111213a = [1,2,3,4,5,6,7,8,9,10]b = a[:4] # 인덱스 0부터 3까지c = a[1:4] # 인덱스 1부터 3까지d = a[0:7:2] # 인덱스 0부터 6까지 인덱스 2씩 건너 띄우기e = a[::-1] # 리스트 a의 역순f = a[::2] # 리스트 전체구간에서 인덱스 2씩 건너띄우기print(&quot;a[:4]&quot;, b)print(&quot;a[1:4]&quot;, c)print(&quot;a[0:7:2]&quot;, d)print(&quot;a[::-1]&quot;, e)print(&quot;a[::2]&quot;, f) a[:4] [1, 2, 3, 4] a[1:4] [2, 3, 4] a[0:7:2] [1, 3, 5, 7] a[::-1] [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] a[::2] [1, 3, 5, 7, 9] 12345a = ['alice', 'bob', 'cat']b = ['apple', 'banana', 'cherry']c = a+bprint(c) ['alice', 'bob', 'cat', 'apple', 'banana', 'cherry'] 12345a = ['a','b','c']b = a*3c = a*0print(&quot;a * 3:&quot;, b)print(&quot;a * 0:&quot;, c) a * 3: ['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c'] a * 0: [] 리스트 값 수정하기1234a = [0,1,2]a[1] = &quot;b&quot;print(a) [0, 'b', 2] 리스트 값 추가하기123456a = [100, 200, 300]a.append(400)print(a)a.append([500,600])print(a) [100, 200, 300, 400] [100, 200, 300, 400, [500, 600]] 1234a = [1,2,3]a.extend([40,500])print('a.extend([40,500]) result')print(a) a.extend([40,500]) result [1, 2, 3, 40, 500] 1234a = [0,1,2]a.insert(1,100)print(a) [0, 100, 1, 2] 12345678910111213a = [0,1,2,3]a[2:2] = [100,200]print(a)# 시작과 끝의 범위보다 큰 수를 덮어쓰는 예시b = [0,1,2,3]b[1:2] = [100,200,300,400] print(b)# 시작과 끝의 범위가 작을때의 예시c = [0,1,2,3]c[1:3] = [100]print(c) [0, 1, 100, 200, 2, 3] [0, 100, 200, 300, 400, 2, 3] [0, 100, 3] 리스트 값 삭제하기123456789a =[1,2,1,2]#리스트의 첫번째 1이 삭제a.remove(1)print(a)#리스트의 두번째 1이 삭제a.remove(1)print(a) [2, 1, 2] [2, 2] 12345678910a = [0,1,2,3,4,5,6,7,8,9]# 1 삭제del a[1]print(a)b = [0,1,2,3,4,5,6,7,8,9]# 범위로 삭제del b[1:3] #list는 항상 시작하는 index부터, 종료하는 n의 n-1까지의 범위를 잡아줍니다.print(b) [0, 2, 3, 4, 5, 6, 7, 8, 9] [0, 3, 4, 5, 6, 7, 8, 9] 123456#인덱스를 지정한 pop()a = [0,1,2,3,4]r = a.pop(1)print(a)print(r) [0, 2, 3, 4] 1 123456#인덱스를 지정하지 않은 pop()b = ['a','b','c','d']x = b.pop()print(b)print(x) ['a', 'b', 'c'] d 그 외 유용한 메서드12345a = [0,1,2,3]print(a)a.clear()print(a) [0, 1, 2, 3] [] 12a = [&quot;Gold&quot;, &quot;Gold&quot;, &quot;Silver&quot;, &quot;Silver&quot;]print(&quot;Silver가 처음 등장하는 인덱스 번호&quot;, a.index(&quot;Silver&quot;)) Silver가 처음 등장하는 인덱스 번호 2 12345678a = [1, 4, 5, 2, 3]b = [1, 4, 5, 2, 3]a.sort()print(&quot;sort():&quot;,a)b.sort(reverse=True)print(&quot;sort(reverse=True):&quot;, b) sort(): [1, 2, 3, 4, 5] sort(reverse=True): [5, 4, 3, 2, 1] 1234b = [4,3,2,'a']b.sort()print(b) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-38-1624da3f09a9&gt; in &lt;module&gt;() 1 b = [4,3,2,'a'] 2 ----&gt; 3 b.sort() 4 print(b) TypeError: '&lt;' not supported between instances of 'str' and 'int' 튜플1234567891011tuple1 = (0) # 끝에 콤마(,)를 붙이지 않았을 때tuple2 = (0,) # 끝에 콤마(,)를 붙여줬을 때tuple3 = 0,1,2print(tuple1)print(tuple2)print(tuple3)print(type(tuple1)) # 콤마(,)를 붙여주지 않으면 튜플이 아닙니다.print(type(tuple2)) # 콤마(,)를 붙여주어야 튜플 자료형 입니다.print(type(tuple3)) # 여러개의 값 일경우 괄호를 없애주어도 튜플 자료형 입니다. 0 (0,) (0, 1, 2) &lt;class 'int'&gt; &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 12a = (0,1,2,3,'a')del a['a'] --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-41-c41b8ecfc68f&gt; in &lt;module&gt;() 1 a = (0,1,2,3,'a') ----&gt; 2 del a['a'] TypeError: 'tuple' object does not support item deletion 12a = (0,1,2,3,'a')a[1]='t' --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-42-04fb068f82e0&gt; in &lt;module&gt;() 1 a = (0,1,2,3,'a') ----&gt; 2 a[1]='t' TypeError: 'tuple' object does not support item assignment 튜플 인덱싱 및 슬라이싱 하기1234t = (0,1,2,'b',4)print(t[1])print(t[3]) 123t = (0,1,2,3,4)print(t[2:])print(t[0:2]) (2, 3, 4) (0, 1) 더하기 및 곱셈 연산자 사용12345t1 = (0,1,2,3,4)t2 = ('a','b','c')t3 = t1+t2print(t1+t2)print(t3) 123t1 = ('a','b')print(t1*0)print(t1*3) 딕셔너리12345dic = {'teacher':'alice', 'class': 5, 'studentid': '15', 'list':[1,2,3]}print(dic['teacher'])print(dic['class'])print(dic['list']) alice 5 [1, 2, 3] 12dic = {'teacher':'alice', 'class': 5, 'studentid': '15', 'list':[1,2,3]}print(dic['real']) --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-44-fd82dcc94904&gt; in &lt;module&gt;() 1 dic = {'teacher':'alice', 'class': 5, 'studentid': '15', 'list':[1,2,3]} ----&gt; 2 print(dic['real']) KeyError: 'real' 12a = {'name': 'bob', 'job': 'farmer', 'age': 35}a.keys() dict_keys(['name', 'job', 'age']) 12a = {'name': 'bob', 'job': 'farmer', 'age': 35}a.values() dict_values(['bob', 'farmer', 35]) 1234a = {'name': 'chris', 'job': 'painter', 'age': 30}print(a.get('name'))print(a.get('dinner'))print(a.get('dinner', 'empty')) chris None empty 집합 연산자12345678s = {}print(type(s))s = set()print(type(s))s = {1,2,3}print(type(s)) &lt;class 'dict'&gt; &lt;class 'set'&gt; &lt;class 'set'&gt; 1234567a = {1,3,5}b = {2,4,6}c = a|bd = a.union(b)print(&quot;a|b:&quot;, c)print(&quot;a.union(b)&quot;, d) a|b: {1, 2, 3, 4, 5, 6} a.union(b) {1, 2, 3, 4, 5, 6} 1234567891011a = {1,3,5}b = {2,4,6}c = a&amp;bprint(c)e = {1,2,5}f = {2,3,5}g1 = e&amp;fg2 = e.intersection(f)print(&quot;e&amp;f:&quot;, g1)print(&quot;e.intersection(f):&quot;, g2) set() e&amp;f: {2, 5} e.intersection(f): {2, 5} 1234567a = {1,3,5}b = {2,4,5}c1 = a-bc2 = a.difference(b)print(&quot;a-b:&quot;, c1)print(&quot;a.difference(b)&quot;, c2) a-b: {1, 3} a.difference(b) {1, 3} 1234567a = {1,2,3,4,5}b = {3,4,5,6,7}c1 = a^bc2 = a.symmetric_difference(b)print(&quot;a^b&quot;, c1)print(&quot;a.symmetric_difference(b)&quot;, c2) a^b {1, 2, 6, 7} a.symmetric_difference(b) {1, 2, 6, 7} if 조건문12345678910a = -5if a&gt;5: print('a is bigger than 5')elif a &gt; 0: print(&quot;a is bigger than 0 but a is smaller than 5 &quot;)else: print(&quot;a is negative&quot;) a is negative 반복문1print(&quot;Hello World&quot;) Hello World 123print(&quot;Hello World&quot;)print(&quot;Hello World&quot;)print(&quot;Hello World&quot;) Hello World Hello World Hello World 12for i in range(10000): print(&quot;Hello World&quot;) \u001b[1;30;43m스트리밍 출력 내용이 길어서 마지막 5000줄이 삭제되었습니다.\u001b[0m Hello World Hello World Hello World Hello World (손으로 자름.) Hello World Hello World 1234567a = &quot;Kaggle&quot;for x in a: print(x) if x == 'g': break K a g 123alphabets = ['A', 'B', 'C']for index, value in enumerate(alphabets): print(index, value) 0 A 1 B 2 C","link":"/2021/11/02/python_basic/"},{"title":"to prepare kaggle Competition","text":"#Kaggle Competition 준비하기","link":"/2021/11/11/KggComp_/"}],"tags":[{"name":"python","slug":"python","link":"/tags/python/"},{"name":"bioinformatics","slug":"bioinformatics","link":"/tags/bioinformatics/"},{"name":"BioDataScientist","slug":"BioDataScientist","link":"/tags/BioDataScientist/"},{"name":"BioData_Science","slug":"BioData-Science","link":"/tags/BioData-Science/"},{"name":"google, colaboratory, github, upload","slug":"google-colaboratory-github-upload","link":"/tags/google-colaboratory-github-upload/"},{"name":"machineLearning","slug":"machineLearning","link":"/tags/machineLearning/"},{"name":"decisionTree","slug":"decisionTree","link":"/tags/decisionTree/"},{"name":"predictionModel","slug":"predictionModel","link":"/tags/predictionModel/"},{"name":"Classifier","slug":"Classifier","link":"/tags/Classifier/"},{"name":"DataScience","slug":"DataScience","link":"/tags/DataScience/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"kaggle","slug":"kaggle","link":"/tags/kaggle/"},{"name":"summary","slug":"summary","link":"/tags/summary/"},{"name":"kaggle_dictation","slug":"kaggle-dictation","link":"/tags/kaggle-dictation/"},{"name":"Plotly","slug":"Plotly","link":"/tags/Plotly/"},{"name":"plot","slug":"plot","link":"/tags/plot/"},{"name":"BarGraph","slug":"BarGraph","link":"/tags/BarGraph/"},{"name":"HorizontalBar","slug":"HorizontalBar","link":"/tags/HorizontalBar/"},{"name":"Scatter","slug":"Scatter","link":"/tags/Scatter/"},{"name":"ScatterLine","slug":"ScatterLine","link":"/tags/ScatterLine/"},{"name":"Bargraph","slug":"Bargraph","link":"/tags/Bargraph/"},{"name":"Donut_Chart","slug":"Donut-Chart","link":"/tags/Donut-Chart/"},{"name":"makeBlog, makegithub","slug":"makeBlog-makegithub","link":"/tags/makeBlog-makegithub/"},{"name":"Study","slug":"Study","link":"/tags/Study/"},{"name":"Numpy","slug":"Numpy","link":"/tags/Numpy/"},{"name":"Treemap","slug":"Treemap","link":"/tags/Treemap/"},{"name":"Pandas","slug":"Pandas","link":"/tags/Pandas/"},{"name":"List","slug":"List","link":"/tags/List/"},{"name":"studyPython","slug":"studyPython","link":"/tags/studyPython/"},{"name":"Tuple","slug":"Tuple","link":"/tags/Tuple/"},{"name":"kaggleNote","slug":"kaggleNote","link":"/tags/kaggleNote/"},{"name":"googleColab","slug":"googleColab","link":"/tags/googleColab/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Matplotlib","slug":"Matplotlib","link":"/tags/Matplotlib/"},{"name":"Seaborn","slug":"Seaborn","link":"/tags/Seaborn/"},{"name":"paperReview","slug":"paperReview","link":"/tags/paperReview/"},{"name":"title","slug":"title","link":"/tags/title/"},{"name":"coding","slug":"coding","link":"/tags/coding/"},{"name":"DataFrame","slug":"DataFrame","link":"/tags/DataFrame/"},{"name":"python_basic","slug":"python-basic","link":"/tags/python-basic/"},{"name":"method","slug":"method","link":"/tags/method/"},{"name":"repository","slug":"repository","link":"/tags/repository/"},{"name":"make","slug":"make","link":"/tags/make/"},{"name":"makeBlog","slug":"makeBlog","link":"/tags/makeBlog/"},{"name":"panel","slug":"panel","link":"/tags/panel/"},{"name":"Series","slug":"Series","link":"/tags/Series/"}],"categories":[{"name":"BDS","slug":"BDS","link":"/categories/BDS/"},{"name":"DecisionTree","slug":"DecisionTree","link":"/categories/DecisionTree/"},{"name":"index","slug":"index","link":"/categories/index/"},{"name":"python - plotly","slug":"python-plotly","link":"/categories/python-plotly/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"kaggle","slug":"kaggle","link":"/categories/kaggle/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"init","slug":"init","link":"/categories/init/"},{"name":"Matplotlib","slug":"Python/Matplotlib","link":"/categories/Python/Matplotlib/"},{"name":"Seaborn","slug":"Python/Matplotlib/Seaborn","link":"/categories/Python/Matplotlib/Seaborn/"}]}